/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/AnimImage.js":
/*!**************************!*\
  !*** ./src/AnimImage.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AnimImage =\n/*#__PURE__*/\nfunction () {\n  function AnimImage() {\n    _classCallCheck(this, AnimImage);\n\n    // width/height are *frame* width/height\n    this._width = 0;\n    this._height = 0;\n    this._maxRadius = 0;\n    this._index = 0;\n    this._frames = 1;\n    this._imageSourceName = \"\";\n    this._horizCells = 1;\n  }\n\n  _createClass(AnimImage, [{\n    key: \"loadFromXML\",\n    value: function loadFromXML(xml) {\n      var attr = xml.attributes;\n      this._imageSourceName = attr.getNamedItem(\"URL\").nodeValue;\n      this._width = attr.getNamedItem(\"WIDTH\").nodeValue;\n      this._height = attr.getNamedItem(\"HEIGHT\").nodeValue;\n      this._frames = attr.getNamedItem(\"FRAMES\").nodeValue;\n      this._index = attr.getNamedItem(\"INDEX\").nodeValue; // Note that we don't actually know this until we load the image, as we don't have the total image dimensions\n      // i.e. we have the size of each cell/frame, and the number of cells, but we don't know the arrangement (e.g. 2x4 or 1x8)\n      // Must be set once the image is loaded if we have sprite sheets with different horizontal/vertical number of cells/frames\n\n      this._horizCells = Math.sqrt(this._frames);\n    }\n  }, {\n    key: \"setMaxRadius\",\n    value: function setMaxRadius(radius) {\n      this._maxRadius = radius;\n    }\n  }, {\n    key: \"getMaxRadius\",\n    value: function getMaxRadius() {\n      return this._maxRadius;\n    }\n  }, {\n    key: \"setWidth\",\n    value: function setWidth(width) {\n      this._width = width;\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this._width;\n    }\n  }, {\n    key: \"setHeight\",\n    value: function setHeight(height) {\n      this._height = height;\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this._height;\n    }\n  }, {\n    key: \"getFramesCount\",\n    value: function getFramesCount() {\n      return this._frames;\n    }\n  }, {\n    key: \"setIndex\",\n    value: function setIndex(index) {\n      this._index = index;\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex() {\n      return this._index;\n    }\n  }, {\n    key: \"getFrameX\",\n    value: function getFrameX(frameIndex) {\n      return this._width * (frameIndex % this._horizCells);\n    }\n  }, {\n    key: \"getFrameY\",\n    value: function getFrameY(frameIndex) {\n      return this._height * Math.floor(frameIndex / this._horizCells);\n    }\n  }, {\n    key: \"setFilename\",\n    value: function setFilename(filename) {\n      this._imageSourceName = filename;\n    }\n  }, {\n    key: \"getFilename\",\n    value: function getFilename() {\n      return this._imageSourceName;\n    }\n  }, {\n    key: \"setName\",\n    value: function setName(name) {\n      this._name = name;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }]);\n\n  return AnimImage;\n}();\n\nexports.default = AnimImage;\n\n//# sourceURL=webpack:///./src/AnimImage.js?");

/***/ }),

/***/ "./src/AttributeNode.js":
/*!******************************!*\
  !*** ./src/AttributeNode.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AttributeNode =\n/*#__PURE__*/\nfunction () {\n  function AttributeNode() {\n    _classCallCheck(this, AttributeNode);\n\n    this.frame = 0;\n    this.value = 0;\n    this.isCurve = false;\n    this.c0x = 0;\n    this.c0y = 0;\n    this.c1x = 0;\n    this.c1y = 0;\n  }\n\n  _createClass(AttributeNode, [{\n    key: \"compare\",\n    value: function compare(other) {\n      return this.frame > other.frame;\n    }\n  }, {\n    key: \"setCurvePoints\",\n    value: function setCurvePoints(x0, y0, x1, y1) {\n      this.c0x = x0;\n      this.c0y = y0;\n      this.c1x = x1;\n      this.c1y = y1;\n      this.isCurve = true;\n    }\n  }, {\n    key: \"toggleCurve\",\n    value: function toggleCurve() {\n      this.isCurve = !this.isCurve;\n    }\n  }, {\n    key: \"loadFromXML\",\n    value: function loadFromXML(xml) {\n      if (xml) {\n        this.setCurvePoints((0, _Utils.getNodeAttrValue)(xml, \"LEFT_CURVE_POINT_X\"), (0, _Utils.getNodeAttrValue)(xml, \"LEFT_CURVE_POINT_Y\"), (0, _Utils.getNodeAttrValue)(xml, \"RIGHT_CURVE_POINT_X\"), (0, _Utils.getNodeAttrValue)(xml, \"RIGHT_CURVE_POINT_Y\"));\n      }\n    }\n  }]);\n\n  return AttributeNode;\n}();\n\nexports.default = AttributeNode;\n\n//# sourceURL=webpack:///./src/AttributeNode.js?");

/***/ }),

/***/ "./src/Effect.js":
/*!***********************!*\
  !*** ./src/Effect.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EndLetFree = exports.EndLoopAround = exports.EndKill = exports.EmInAndOut = exports.EmSpecified = exports.EmOutwards = exports.EmInwards = exports.TypeEllipse = exports.TypeLine = exports.TypeArea = exports.TypePoint = undefined;\n\nvar _Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nvar _Entity2 = __webpack_require__(/*! ./Entity */ \"./src/Entity.js\");\n\nvar _Entity3 = _interopRequireDefault(_Entity2);\n\nvar _Emitter = __webpack_require__(/*! ./Emitter */ \"./src/Emitter.js\");\n\nvar _Emitter2 = _interopRequireDefault(_Emitter);\n\nvar _EmitterArray = __webpack_require__(/*! ./EmitterArray */ \"./src/EmitterArray.js\");\n\nvar _EmitterArray2 = _interopRequireDefault(_EmitterArray);\n\nvar _EffectsLibrary = __webpack_require__(/*! ./EffectsLibrary */ \"./src/EffectsLibrary.js\");\n\nvar _EffectsLibrary2 = _interopRequireDefault(_EffectsLibrary);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar TypePoint = exports.TypePoint = 0;\nvar TypeArea = exports.TypeArea = 1;\nvar TypeLine = exports.TypeLine = 2;\nvar TypeEllipse = exports.TypeEllipse = 3;\nvar EmInwards = exports.EmInwards = 0;\nvar EmOutwards = exports.EmOutwards = 1;\nvar EmSpecified = exports.EmSpecified = 2;\nvar EmInAndOut = exports.EmInAndOut = 3;\nvar EndKill = exports.EndKill = 0;\nvar EndLoopAround = exports.EndLoopAround = 1;\nvar EndLetFree = exports.EndLetFree = 2;\nvar g_defaultEffect = {\n  _class: TypePoint,\n  _currentEffectFrame: 0,\n  _handleCenter: false,\n  _source: null,\n  _lockAspect: true,\n  _particlesCreated: false,\n  _suspendTime: 0,\n  _gx: 0,\n  _gy: 0,\n  _mgx: 0,\n  _mgy: 0,\n  _emitAtPoints: false,\n  _emissionType: EmInwards,\n  _effectLength: 0,\n  _parentEmitter: null,\n  _spawnAge: 0,\n  _index: 0,\n  _particleCount: 0,\n  _idleTime: 0,\n  _traverseEdge: false,\n  _endBehavior: EndKill,\n  _distanceSetByLife: false,\n  _reverseSpawn: false,\n  _spawnDirection: 1,\n  _dying: false,\n  _allowSpawning: true,\n  _ellipseArc: 360.0,\n  _ellipseOffset: 0,\n  _effectLayer: 0,\n  _doesNotTimeout: false,\n  _particleManager: null,\n  _frames: 32,\n  _animWidth: 128,\n  _animHeight: 128,\n  _looped: false,\n  _animX: 0,\n  _animY: 0,\n  _seed: 0,\n  _zoom: 1.0,\n  _frameOffset: 0,\n  _currentLife: 0,\n  _currentAmount: 0,\n  _currentSizeX: 0,\n  _currentSizeY: 0,\n  _currentVelocity: 0,\n  _currentSpin: 0,\n  _currentWeight: 0,\n  _currentWidth: 0,\n  _currentHeight: 0,\n  _currentAlpha: 0,\n  _currentEmissionAngle: 0,\n  _currentEmissionRange: 0,\n  _currentStretch: 0,\n  _currentGlobalZ: 0,\n  _overrideSize: false,\n  _overrideEmissionAngle: false,\n  _overrideEmissionRange: false,\n  _overrideAngle: false,\n  _overrideLife: false,\n  _overrideAmount: false,\n  _overrideVelocity: false,\n  _overrideSpin: false,\n  _overrideSizeX: false,\n  _overrideSizeY: false,\n  _overrideWeight: false,\n  _overrideAlpha: false,\n  _overrideStretch: false,\n  _overrideGlobalZ: false,\n  _bypassWeight: false,\n  _isCompiled: false\n};\n\nvar Effect =\n/*#__PURE__*/\nfunction (_Entity) {\n  _inherits(Effect, _Entity);\n\n  function Effect(other, particleManager) {\n    var _this2;\n\n    _classCallCheck(this, Effect);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Effect).call(this, other));\n\n    if (other === undefined) {\n      for (var key in g_defaultEffect) {\n        _this2[key] = g_defaultEffect[key];\n      }\n\n      _this2._arrayOwner = true;\n      _this2._inUse = [];\n\n      for (var i = 0; i < 10; i++) {\n        _this2._inUse[i] = [];\n      }\n\n      _this2._cAmount = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cLife = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cSizeX = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cSizeY = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cVelocity = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cWeight = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cSpin = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cStretch = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cGlobalZ = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this2._cAlpha = new _EmitterArray2.default(0, 1.0);\n      _this2._cEmissionAngle = new _EmitterArray2.default(_EffectsLibrary2.default.angleMin, _EffectsLibrary2.default.angleMax);\n      _this2._cEmissionRange = new _EmitterArray2.default(_EffectsLibrary2.default.emissionRangeMin, _EffectsLibrary2.default.emissionRangeMax);\n      _this2._cWidth = new _EmitterArray2.default(_EffectsLibrary2.default.dimensionsMin, _EffectsLibrary2.default.dimensionsMax);\n      _this2._cHeight = new _EmitterArray2.default(_EffectsLibrary2.default.dimensionsMin, _EffectsLibrary2.default.dimensionsMax);\n      _this2._cEffectAngle = new _EmitterArray2.default(_EffectsLibrary2.default.angleMin, _EffectsLibrary2.default.angleMax);\n    } else {\n      for (var _key in g_defaultEffect) {\n        _this2[_key] = other[_key];\n      }\n\n      _this2._particleManager = particleManager;\n      _this2._arrayOwner = false;\n      _this2._inUse = [];\n\n      for (var _i = 0; _i < 10; _i++) {\n        _this2._inUse[_i] = [];\n      }\n\n      _this2._cAmount = other._cAmount;\n      _this2._cLife = other._cLife;\n      _this2._cSizeX = other._cSizeX;\n      _this2._cSizeY = other._cSizeY;\n      _this2._cVelocity = other._cVelocity;\n      _this2._cWeight = other._cWeight;\n      _this2._cSpin = other._cSpin;\n      _this2._cAlpha = other._cAlpha;\n      _this2._cEmissionAngle = other._cEmissionAngle;\n      _this2._cEmissionRange = other._cEmissionRange;\n      _this2._cWidth = other._cWidth;\n      _this2._cHeight = other._cHeight;\n      _this2._cEffectAngle = other._cEffectAngle;\n      _this2._cStretch = other._cStretch;\n      _this2._cGlobalZ = other._cGlobalZ;\n\n      _this2.setEllipseArc(other._ellipseArc);\n\n      _this2._dob = particleManager.getCurrentTime();\n\n      _this2.setOKtoRender(false);\n\n      for (var _i2 = 0; _i2 < other._children.length; _i2++) {\n        var _e = new _Emitter2.default(other._children[_i2], particleManager);\n\n        _e.setParentEffect(_assertThisInitialized(_assertThisInitialized(_this2)));\n\n        _e.setParent(_assertThisInitialized(_assertThisInitialized(_this2)));\n      }\n    }\n\n    return _this2;\n  }\n\n  _createClass(Effect, [{\n    key: \"hideAll\",\n    value: function hideAll() {\n      for (var i = 0; i < this._children.length; i++) {\n        this._children[i].hideAll();\n      }\n    }\n  }, {\n    key: \"getEffectLayer\",\n    value: function getEffectLayer() {\n      return this._effectLayer;\n    }\n  }, {\n    key: \"setEffectLayer\",\n    value: function setEffectLayer(layer) {\n      this._effectLayer = layer;\n    }\n  }, {\n    key: \"showOne\",\n    value: function showOne(e) {\n      for (var i = 0; i < this._children.length; i++) {\n        this._children[i].setVisible(false);\n      }\n\n      e.setVisible(true);\n    }\n  }, {\n    key: \"emitterCount\",\n    value: function emitterCount() {\n      return this._children.length;\n    }\n  }, {\n    key: \"setParticleManager\",\n    value: function setParticleManager(particleManager) {\n      this._particleManager = particleManager;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.capture();\n      this._age = this._particleManager.getCurrentTime() - this._dob;\n      if (this._spawnAge < this._age) this._spawnAge = this._age;\n\n      if (this._effectLength > 0 && this._age > this._effectLength) {\n        this._dob = this._particleManager.getCurrentTime();\n        this._age = 0;\n      }\n\n      this._currentEffectFrame = this._age / _EffectsLibrary2.default.getLookupFrequency();\n\n      if (!this._overrideSize) {\n        switch (this._class) {\n          case TypePoint:\n            this._currentWidth = 0;\n            this._currentHeight = 0;\n            break;\n\n          case TypeArea:\n          case TypeEllipse:\n            this._currentWidth = this.getWidth(this._currentEffectFrame);\n            this._currentHeight = this.getHeight(this._currentEffectFrame);\n            break;\n\n          case TypeLine:\n            this._currentWidth = this.getWidth(this._currentEffectFrame);\n            this._currentHeight = 0;\n            break;\n        }\n      } // can be optimized\n\n\n      if (this._handleCenter && this._class !== TypePoint) {\n        this._handleX = this._currentWidth * 0.5;\n        this._handleY = this._currentHeight * 0.5;\n      } else {\n        this._handleX = 0;\n        this._handleY = 0;\n      }\n\n      if (this.hasParticles() || this._doesNotTimeout) {\n        this._idleTime = 0;\n      } else {\n        ++this._idleTime;\n      }\n\n      if (this._parentEmitter) {\n        var parentEffect = this._parentEmitter.getParentEffect();\n\n        if (!this._overrideLife) this._currentLife = this.getLife(this._currentEffectFrame) * parentEffect._currentLife;\n        if (!this._overrideAmount) this._currentAmount = this.getAmount(this._currentEffectFrame) * parentEffect._currentAmount;\n\n        if (this._lockAspect) {\n          if (!this._overrideSizeX) this._currentSizeX = this.getSizeX(this._currentEffectFrame) * parentEffect._currentSizeX;\n          if (!this._overrideSizeY) this._currentSizeY = this._currentSizeX * parentEffect._currentSizeY;\n        } else {\n          if (!this._overrideSizeX) this._currentSizeX = this.getSizeX(this._currentEffectFrame) * parentEffect._currentSizeX;\n          if (!this._overrideSizeY) this._currentSizeY = this.getSizeY(this._currentEffectFrame) * parentEffect._currentSizeY;\n        }\n\n        if (!this._overrideVelocity) this._currentVelocity = this.getVelocity(this._currentEffectFrame) * parentEffect._currentVelocity;\n        if (!this._overrideWeight) this._currentWeight = this.getWeight(this._currentEffectFrame) * parentEffect._currentWeight;\n        if (!this._overrideSpin) this._currentSpin = this.getSpin(this._currentEffectFrame) * parentEffect._currentSpin;\n        if (!this._overrideAlpha) this._currentAlpha = this.getAlpha(this._currentEffectFrame) * parentEffect._currentAlpha;\n        if (!this._overrideEmissionAngle) this._currentEmissionAngle = this.getEmissionAngle(this._currentEffectFrame);\n        if (!this._overrideEmissionRange) this._currentEmissionRange = this.getEmissionRange(this._currentEffectFrame);\n        if (!this._overrideAngle) this._angle = this.getEffectAngle(this._currentEffectFrame);\n        if (!this._overrideStretch) this._currentStretch = this.getStretch(this._currentEffectFrame) * parentEffect._currentStretch;\n        if (!this._overrideGlobalZ) this._currentGlobalZ = this.getGlobalZ(this._currentEffectFrame) * parentEffect._currentGlobalZ;\n      } else {\n        if (!this._overrideLife) this._currentLife = this.getLife(this._currentEffectFrame);\n        if (!this._overrideAmount) this._currentAmount = this.getAmount(this._currentEffectFrame);\n\n        if (this._lockAspect) {\n          if (!this._overrideSizeX) this._currentSizeX = this.getSizeX(this._currentEffectFrame);\n          if (!this._overrideSizeY) this._currentSizeY = this._currentSizeX;\n        } else {\n          if (!this._overrideSizeX) this._currentSizeX = this.getSizeX(this._currentEffectFrame);\n          if (!this._overrideSizeY) this._currentSizeY = this.getSizeY(this._currentEffectFrame);\n        }\n\n        if (!this._overrideVelocity) this._currentVelocity = this.getVelocity(this._currentEffectFrame);\n        if (!this._overrideWeight) this._currentWeight = this.getWeight(this._currentEffectFrame);\n        if (!this._overrideSpin) this._currentSpin = this.getSpin(this._currentEffectFrame);\n        if (!this._overrideAlpha) this._currentAlpha = this.getAlpha(this._currentEffectFrame);\n        if (!this._overrideEmissionAngle) this._currentEmissionAngle = this.getEmissionAngle(this._currentEffectFrame);\n        if (!this._overrideEmissionRange) this._currentEmissionRange = this.getEmissionRange(this._currentEffectFrame);\n        if (!this._overrideAngle) this._angle = this.getEffectAngle(this._currentEffectFrame);\n        if (!this._overrideStretch) this._currentStretch = this.getStretch(this._currentEffectFrame);\n        if (!this._overrideGlobalZ) this._currentGlobalZ = this.getGlobalZ(this._currentEffectFrame);\n      }\n\n      if (!this._overrideGlobalZ) this._z = this._currentGlobalZ;\n      if (this._currentWeight === 0) this._bypassWeight = true;\n      if (this._parentEmitter) this._dying = this._parentEmitter.isDying();\n\n      _get(_getPrototypeOf(Effect.prototype), \"update\", this).call(this); //Effect.$superp.Update.call(this);\n\n\n      if (this._idleTime > this._particleManager.getIdleTimeLimit()) this._dead = 1;\n\n      if (this._dead) {\n        if (this.getChildCount() === 0) {\n          this.destroy();\n          return false;\n        } else {\n          this.killChildren();\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"hasParticles\",\n    value: function hasParticles() {\n      for (var i = 0; i < this._children.length; i++) {\n        if (this._children[i].getChildCount() > 0) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getParticleManager\",\n    value: function getParticleManager() {\n      return this._particleManager;\n    }\n  }, {\n    key: \"getParticles\",\n    value: function getParticles(layer) {\n      return this._inUse[layer];\n    }\n  }, {\n    key: \"isDying\",\n    value: function isDying() {\n      return this._dying;\n    }\n  }, {\n    key: \"softKill\",\n    value: function softKill() {\n      this._dying = true;\n    }\n  }, {\n    key: \"hardKill\",\n    value: function hardKill() {\n      this._particleManager.removeEffect(this);\n\n      this.destroy();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(releaseChildren) {\n      this._parentEmitter = null;\n      this._directoryEffects = [];\n      this._directoryEmitters = [];\n\n      for (var i = 0; i < this._inUse.length; i++) {\n        while (this._inUse[i].length !== 0) {\n          var p = this._inUse[i].pop();\n\n          p.reset();\n\n          this._particleManager.releaseParticle(p);\n\n          this.removeInUse(i, p);\n        }\n\n        this._inUse[i] = [];\n      }\n\n      _get(_getPrototypeOf(Effect.prototype), \"destroy\", this).call(this, releaseChildren); //Effect.$superp.Destroy.call(this, releaseChildren);\n\n    }\n  }, {\n    key: \"setEndBehavior\",\n    value: function setEndBehavior(behavior) {\n      this._endBehavior = behavior;\n    }\n  }, {\n    key: \"setDistanceSetByLife\",\n    value: function setDistanceSetByLife(value) {\n      this._distanceSetByLife = value;\n    }\n  }, {\n    key: \"setHandleCenter\",\n    value: function setHandleCenter(center) {\n      this._handleCenter = center;\n    }\n  }, {\n    key: \"setReverseSpawn\",\n    value: function setReverseSpawn(reverse) {\n      this._reverseSpawn = reverse;\n    }\n  }, {\n    key: \"setSpawnDirection\",\n    value: function setSpawnDirection() {\n      if (this._reverseSpawn) this._spawnDirection = -1;else this._spawnDirection = 1;\n    }\n  }, {\n    key: \"setAreaSize\",\n    value: function setAreaSize(width, height) {\n      this._overrideSize = true;\n      this._currentWidth = width;\n      this._currentHeight = height;\n    }\n  }, {\n    key: \"setLineLength\",\n    value: function setLineLength(length) {\n      this._overrideSize = true;\n      this._currentWidth = length;\n    }\n  }, {\n    key: \"setEmissionAngle\",\n    value: function setEmissionAngle(angle) {\n      this._overrideEmissionAngle = true;\n      this._currentEmissionAngle = angle;\n    }\n  }, {\n    key: \"setEffectAngle\",\n    value: function setEffectAngle(angle) {\n      this._overrideAngle = true;\n      this._angle = angle;\n    }\n  }, {\n    key: \"setLife\",\n    value: function setLife(life) {\n      this._overrideLife = true;\n      this._currentLife = life;\n    }\n  }, {\n    key: \"setAmount\",\n    value: function setAmount(amount) {\n      this._overrideAmount = true;\n      this._currentAmount = amount;\n    }\n  }, {\n    key: \"setVelocity\",\n    value: function setVelocity(velocity) {\n      this._overrideVelocity = true;\n      this._currentVelocity = velocity;\n    }\n  }, {\n    key: \"setSpin\",\n    value: function setSpin(spin) {\n      this._overrideSpin = true;\n      this._currentSpin = spin;\n    }\n  }, {\n    key: \"setWeight\",\n    value: function setWeight(weight) {\n      this._overrideWeight = true;\n      this._currentWeight = weight;\n    }\n  }, {\n    key: \"setEffectParticleSize\",\n    value: function setEffectParticleSize(sizeX, sizeY) {\n      this._overrideSizeX = true;\n      this._overrideSizeY = true;\n      this._currentSizeX = sizeX;\n      this._currentSizeY = sizeY;\n    }\n  }, {\n    key: \"setSizeX\",\n    value: function setSizeX(sizeX) {\n      this._overrideSizeX = true;\n      this._currentSizeX = sizeX;\n    }\n  }, {\n    key: \"setSizeY\",\n    value: function setSizeY(sizeY) {\n      this._overrideSizeY = true;\n      this._currentSizeY = sizeY;\n    }\n  }, {\n    key: \"setEffectAlpha\",\n    value: function setEffectAlpha(alpha) {\n      this._overrideAlpha = true;\n      this._currentAlpha = alpha;\n    }\n  }, {\n    key: \"setEffectEmissionRange\",\n    value: function setEffectEmissionRange(emissionRange) {\n      this._overrideEmissionRange = true;\n      this._currentEmissionRange = emissionRange;\n    }\n  }, {\n    key: \"setEllipseArc\",\n    value: function setEllipseArc(degrees) {\n      this._ellipseArc = degrees;\n      this._ellipseOffset = 90 - degrees / 2;\n    }\n  }, {\n    key: \"setZ\",\n    value: function setZ(z) {\n      this._overrideGlobalZ = true;\n      this._z = z;\n    }\n  }, {\n    key: \"setStretch\",\n    value: function setStretch(stretch) {\n      this._overrideStretch = true;\n      this._currentStretch = stretch;\n    }\n  }, {\n    key: \"setGroupParticles\",\n    value: function setGroupParticles(v) {\n      for (var i = 0; i < this._children.length; i++) {\n        var _e2 = this._children[i];\n\n        _e2.setGroupParticles(v);\n\n        var effects = _e2.getEffects();\n\n        for (var j = 0; j < effects.length; j++) {\n          effects[j].setGroupParticles(v);\n        }\n      }\n    }\n  }, {\n    key: \"addInUse\",\n    value: function addInUse(layer, p) {\n      // the particle is managed by this Effect\n      this.setGroupParticles(true);\n\n      this._inUse[layer].push(p);\n    }\n  }, {\n    key: \"removeInUse\",\n    value: function removeInUse(layer, p) {\n      (0, _Utils.removeFromList)(this._inUse[layer], p);\n    }\n  }, {\n    key: \"compileAll\",\n    value: function compileAll() {\n      if (this._isCompiled) return;\n      this.compileLife();\n      this.compileAmount();\n      this.compileSizeX();\n      this.compileSizeY();\n      this.compileVelocity();\n      this.compileWeight();\n      this.compileSpin();\n      this.compileAlpha();\n      this.compileEmissionAngle();\n      this.compileEmissionRange();\n      this.compileWidth();\n      this.compileHeight();\n      this.compileAngle();\n      this.compileStretch();\n      this.compileGlobalZ();\n\n      for (var i = 0; i < this._children.length; i++) {\n        this._children[i].compileAll();\n      }\n\n      this._isCompiled = true;\n    }\n  }, {\n    key: \"compileQuick\",\n    value: function compileQuick() {\n      for (var i = 0; i < this._children.length; i++) {\n        e = this._children[i];\n        e.compileQuick();\n        e.resetBypassers();\n      }\n    }\n  }, {\n    key: \"compileAmount\",\n    value: function compileAmount() {\n      this._cAmount.compile();\n    }\n  }, {\n    key: \"compileLife\",\n    value: function compileLife() {\n      this._cLife.compile();\n    }\n  }, {\n    key: \"compileSizeX\",\n    value: function compileSizeX() {\n      this._cSizeX.compile();\n    }\n  }, {\n    key: \"compileSizeY\",\n    value: function compileSizeY() {\n      this._cSizeY.compile();\n    }\n  }, {\n    key: \"compileVelocity\",\n    value: function compileVelocity() {\n      this._cVelocity.compile();\n    }\n  }, {\n    key: \"compileWeight\",\n    value: function compileWeight() {\n      this._cWeight.compile();\n    }\n  }, {\n    key: \"compileSpin\",\n    value: function compileSpin() {\n      this._cSpin.compile();\n    }\n  }, {\n    key: \"compileAlpha\",\n    value: function compileAlpha() {\n      this._cAlpha.compile();\n    }\n  }, {\n    key: \"compileEmissionAngle\",\n    value: function compileEmissionAngle() {\n      this._cEmissionAngle.compile();\n    }\n  }, {\n    key: \"compileEmissionRange\",\n    value: function compileEmissionRange() {\n      this._cEmissionRange.compile();\n    }\n  }, {\n    key: \"compileWidth\",\n    value: function compileWidth() {\n      this._cWidth.compile();\n    }\n  }, {\n    key: \"compileHeight\",\n    value: function compileHeight() {\n      this._cHeight.compile();\n    }\n  }, {\n    key: \"compileAngle\",\n    value: function compileAngle() {\n      this._cEffectAngle.compile();\n    }\n  }, {\n    key: \"compileStretch\",\n    value: function compileStretch() {\n      this._cStretch.compile();\n    }\n  }, {\n    key: \"compileGlobalZ\",\n    value: function compileGlobalZ() {\n      this._cGlobalZ.compile();\n\n      this._cGlobalZ.setCompiled(0, 1.0);\n    }\n  }, {\n    key: \"getLife\",\n    value: function getLife(frame) {\n      return this._cLife.get(frame);\n    }\n  }, {\n    key: \"getAmount\",\n    value: function getAmount(frame) {\n      return this._cAmount.get(frame);\n    }\n  }, {\n    key: \"getSizeX\",\n    value: function getSizeX(frame) {\n      return this._cSizeX.get(frame);\n    }\n  }, {\n    key: \"getSizeY\",\n    value: function getSizeY(frame) {\n      return this._cSizeY.get(frame);\n    }\n  }, {\n    key: \"getVelocity\",\n    value: function getVelocity(frame) {\n      return this._cVelocity.get(frame);\n    }\n  }, {\n    key: \"getWeight\",\n    value: function getWeight(frame) {\n      return this._cWeight.get(frame);\n    }\n  }, {\n    key: \"getSpin\",\n    value: function getSpin(frame) {\n      return this._cSpin.get(frame);\n    }\n  }, {\n    key: \"getAlpha\",\n    value: function getAlpha(frame) {\n      return this._cAlpha.get(frame);\n    }\n  }, {\n    key: \"getEmissionAngle\",\n    value: function getEmissionAngle(frame) {\n      return this._cEmissionAngle.get(frame);\n    }\n  }, {\n    key: \"getEmissionRange\",\n    value: function getEmissionRange(frame) {\n      return this._cEmissionRange.get(frame);\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth(frame) {\n      return this._cWidth.get(frame);\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight(frame) {\n      return this._cHeight.get(frame);\n    }\n  }, {\n    key: \"getEffectAngle\",\n    value: function getEffectAngle(frame) {\n      return this._cEffectAngle.get(frame);\n    }\n  }, {\n    key: \"getStretch\",\n    value: function getStretch(frame) {\n      return this._cStretch.get(frame);\n    }\n  }, {\n    key: \"getGlobalZ\",\n    value: function getGlobalZ(frame) {\n      return this._cGlobalZ.get(frame);\n    }\n  }, {\n    key: \"loadFromXML\",\n    value: function loadFromXML(xml) {\n      var x = new _Utils.XMLHelper(xml);\n      this._class = x.getAttrAsInt(\"TYPE\");\n      this._emitAtPoints = x.getAttrAsBool(\"EMITATPOINTS\");\n      this._mgx = x.getAttrAsInt(\"MAXGX\");\n      this._mgy = x.getAttrAsInt(\"MAXGY\");\n      this._emissionType = x.getAttrAsInt(\"EMISSION_TYPE\");\n      this._effectLength = x.getAttrAsInt(\"EFFECT_LENGTH\");\n      this._ellipseArc = x.getAttrAsFloat(\"ELLIPSE_ARC\");\n      this._handleX = x.getAttrAsInt(\"HANDLE_X\");\n      this._handleY = x.getAttrAsInt(\"HANDLE_Y\");\n      this._lockAspect = x.getAttrAsBool(\"UNIFORM\");\n      this._handleCenter = x.getAttrAsBool(\"HANDLE_CENTER\");\n      this._traverseEdge = x.getAttrAsBool(\"TRAVERSE_EDGE\");\n      this._name = x.getAttr(\"NAME\");\n      this._endBehavior = x.getAttrAsInt(\"END_BEHAVIOUR\");\n      this._distanceSetByLife = x.getAttrAsBool(\"DISTANCE_SET_BY_LIFE\");\n      this._reverseSpawn = x.getAttrAsBool(\"REVERSE_SPAWN_DIRECTION\"); // Build path\n\n      this._path = this._name;\n      var p = xml.parentNode;\n\n      while (p) {\n        var parentName = (0, _Utils.getXMLAttrSafe)(p, \"NAME\");\n        if (parentName !== \"\") this._path = parentName + \"/\" + this._path;\n        p = p.parentNode;\n      }\n\n      var animProps = xml.getElementsByTagName(\"ANIMATION_PROPERTIES\")[0];\n\n      if (animProps) {\n        var a = new _Utils.XMLHelper(animProps);\n        this._frames = a.getAttrAsInt(\"FRAMES\");\n        this._animWidth = a.getAttrAsInt(\"WIDTH\");\n        this._animHeight = a.getAttrAsInt(\"HEIGHT\");\n        this._animX = a.getAttrAsInt(\"X\");\n        this._animY = a.getAttrAsInt(\"Y\");\n        this._seed = a.getAttrAsInt(\"SEED\");\n        this._looped = a.getAttrAsBool(\"LOOPED\");\n        this._zoom = a.getAttrAsFloat(\"ZOOM\");\n        this._frameOffset = a.getAttrAsInt(\"FRAME_OFFSET\");\n      } // todo: pass in EmitterArray instend of bound function (and remove boilerplate functions)\n\n\n      this.readAttribute(xml, this._cAmount, \"AMOUNT\");\n      this.readAttribute(xml, this._cLife, \"LIFE\");\n      this.readAttribute(xml, this._cSizeX, \"SIZEX\");\n      this.readAttribute(xml, this._cSizeY, \"SIZEY\");\n      this.readAttribute(xml, this._cVelocity, \"VELOCITY\");\n      this.readAttribute(xml, this._cWeight, \"WEIGHT\");\n      this.readAttribute(xml, this._cSpin, \"SPIN\");\n      this.readAttribute(xml, this._cAlpha, \"ALPHA\");\n      this.readAttribute(xml, this._cEmissionAngle, \"EMISSIONANGLE\");\n      this.readAttribute(xml, this._cEmissionRange, \"EMISSIONRANGE\");\n      this.readAttribute(xml, this._cWidth, \"AREA_WIDTH\");\n      this.readAttribute(xml, this._cHeight, \"AREA_HEIGHT\");\n      this.readAttribute(xml, this._cEffectAngle, \"ANGLE\");\n\n      if (!this.readAttribute(xml, this._cStretch, \"STRETCH\")) {\n        this.addStretch(0, 1.0);\n      }\n\n      this.readAttribute(xml, this._cGlobalZ, \"GLOBAL_ZOOM\");\n\n      var _this = this;\n\n      (0, _Utils.forEachXMLChild)(xml, \"PARTICLE\", function (n) {\n        var emit = new _Emitter2.default();\n        emit.loadFromXML(n, _this);\n\n        _this.addChild(emit);\n      });\n    }\n  }, {\n    key: \"readAttribute\",\n    value: function readAttribute(xml, emitArray, tag) {\n      var result = false;\n      (0, _Utils.forEachXMLChild)(xml, tag, function (n) {\n        var attr = emitArray.add(parseFloat((0, _Utils.getNodeAttrValue)(n, \"FRAME\")), parseFloat((0, _Utils.getNodeAttrValue)(n, \"VALUE\")));\n        attr.loadFromXML(n.getElementsByTagName(\"CURVE\")[0]);\n        result = true;\n      });\n      return result;\n    }\n  }, {\n    key: \"addStretch\",\n    value: function addStretch(f, v) {\n      return this._cStretch.add(f, v);\n    }\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      return this._path;\n    }\n  }, {\n    key: \"getLifeMaxValue\",\n    value: function getLifeMaxValue() {\n      return this._cLife.getMaxValue();\n    }\n  }, {\n    key: \"getCurrentAmount\",\n    value: function getCurrentAmount() {\n      return this._currentAmount;\n    }\n  }, {\n    key: \"getCurrentLife\",\n    value: function getCurrentLife() {\n      return this._currentLife;\n    }\n  }, {\n    key: \"getCurrentEmissionAngle\",\n    value: function getCurrentEmissionAngle() {\n      return this._currentEmissionAngle;\n    }\n  }, {\n    key: \"getCurrentEmissionRange\",\n    value: function getCurrentEmissionRange() {\n      return this._currentEmissionRange;\n    }\n  }, {\n    key: \"getClass\",\n    value: function getClass() {\n      return this._class;\n    }\n  }, {\n    key: \"setCurrentEffectFrame\",\n    value: function setCurrentEffectFrame(frame) {\n      this._currentEffectFrame = frame;\n    }\n  }, {\n    key: \"getCurrentEffectFrame\",\n    value: function getCurrentEffectFrame() {\n      return this._currentEffectFrame;\n    }\n  }, {\n    key: \"getTraverseEdge\",\n    value: function getTraverseEdge() {\n      return this._traverseEdge;\n    }\n  }, {\n    key: \"getCurrentVelocity\",\n    value: function getCurrentVelocity() {\n      return this._currentVelocity;\n    }\n  }, {\n    key: \"getCurrentSizeX\",\n    value: function getCurrentSizeX() {\n      return this._currentSizeX;\n    }\n  }, {\n    key: \"getCurrentSizeY\",\n    value: function getCurrentSizeY() {\n      return this._currentSizeY;\n    }\n  }, {\n    key: \"getCurrentStretch\",\n    value: function getCurrentStretch() {\n      return this._currentStretch;\n    }\n  }, {\n    key: \"getCurrentWeight\",\n    value: function getCurrentWeight() {\n      return this._currentWeight;\n    }\n  }, {\n    key: \"isBypassWeight\",\n    value: function isBypassWeight() {\n      return this._bypassWeight;\n    }\n  }, {\n    key: \"getCurrentAlpha\",\n    value: function getCurrentAlpha() {\n      return this._currentAlpha;\n    }\n  }, {\n    key: \"setParticlesCreated\",\n    value: function setParticlesCreated(value) {\n      this._particlesCreated = value;\n    }\n  }, {\n    key: \"getCurrentSpin\",\n    value: function getCurrentSpin() {\n      return this._currentSpin;\n    }\n  }, {\n    key: \"getLifeLastFrame\",\n    value: function getLifeLastFrame() {\n      return this._cLife.getLastFrame();\n    }\n  }, {\n    key: \"setEffectLength\",\n    value: function setEffectLength(length) {\n      this._effectLength = length;\n    }\n  }, {\n    key: \"setParentEmitter\",\n    value: function setParentEmitter(emitter) {\n      this._parentEmitter = emitter;\n    }\n  }, {\n    key: \"getHandleCenter\",\n    value: function getHandleCenter() {\n      return this._handleCenter;\n    }\n  }, {\n    key: \"getEmitAtPoints\",\n    value: function getEmitAtPoints() {\n      return this._emitAtPoints;\n    }\n  }, {\n    key: \"getCurrentWidth\",\n    value: function getCurrentWidth() {\n      return this._currentWidth;\n    }\n  }, {\n    key: \"getCurrentHeight\",\n    value: function getCurrentHeight() {\n      return this._currentHeight;\n    }\n  }, {\n    key: \"getEllipseArc\",\n    value: function getEllipseArc() {\n      return this._ellipseArc;\n    }\n  }, {\n    key: \"getEllipseOffset\",\n    value: function getEllipseOffset() {\n      return this._ellipseOffset;\n    }\n  }, {\n    key: \"getEmissionType\",\n    value: function getEmissionType() {\n      return this._emissionType;\n    }\n  }, {\n    key: \"getParentEmitter\",\n    value: function getParentEmitter() {\n      return this._parentEmitter;\n    }\n  }, {\n    key: \"getMGX\",\n    value: function getMGX() {\n      return this._mgx;\n    }\n  }, {\n    key: \"getMGY\",\n    value: function getMGY() {\n      return this._mgy;\n    }\n  }, {\n    key: \"getImages\",\n    value: function getImages(images) {\n      for (var i = 0; i < this._children.length; i++) {\n        this._children[i].getImages(images);\n      }\n    }\n  }]);\n\n  return Effect;\n}(_Entity3.default);\n\nexports.default = Effect;\n\n//# sourceURL=webpack:///./src/Effect.js?");

/***/ }),

/***/ "./src/EffectsLibrary.js":
/*!*******************************!*\
  !*** ./src/EffectsLibrary.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AnimImage = __webpack_require__(/*! ./AnimImage */ \"./src/AnimImage.js\");\n\nvar _AnimImage2 = _interopRequireDefault(_AnimImage);\n\nvar _Effect = __webpack_require__(/*! ./Effect */ \"./src/Effect.js\");\n\nvar _Effect2 = _interopRequireDefault(_Effect);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar EffectsLibrary =\n/*#__PURE__*/\nfunction () {\n  //\n  function EffectsLibrary() {\n    _classCallCheck(this, EffectsLibrary);\n\n    _defineProperty(this, \"_lookupFrequency\", void 0);\n\n    _defineProperty(this, \"_updateTime\", void 0);\n\n    _defineProperty(this, \"_lookupFrequencyOverTime\", void 0);\n\n    _defineProperty(this, \"_updateFrequency\", void 0);\n\n    if (!EffectsLibrary.instance) {\n      EffectsLibrary.instance = this;\n    }\n\n    return EffectsLibrary.instance;\n  }\n\n  _createClass(EffectsLibrary, [{\n    key: \"init\",\n    value: function init() {\n      this.setUpdateFrequency(30.0);\n      this._lookupFrequency = this._updateTime;\n      this._lookupFrequencyOverTime = 1.0;\n      this.clearAll();\n    }\n  }, {\n    key: \"load\",\n    value: function load(xml) {\n      //  console.log(xml);\n      // Only allow loading one library\n      this.clearAll();\n      var shapes = xml.getElementsByTagName(\"SHAPES\")[0];\n      shapes = shapes.getElementsByTagName(\"IMAGE\");\n\n      for (var i = 0; i < shapes.length; i++) {\n        // console.log(shapes[i].attributes.getNamedItem(\"URL\").nodeValue);\n        var img = new _AnimImage2.default();\n        img.loadFromXML(shapes[i]);\n\n        this._shapeList.push(img);\n      } // Traverse top down\n\n\n      this.m_currentFolder = null;\n      this.loadEffectElements(xml.getElementsByTagName(\"EFFECTS\")[0].children);\n    }\n  }, {\n    key: \"loadEffectElements\",\n    value: function loadEffectElements(effects) {\n      for (var i = 0; i < effects.length; i++) {\n        if (effects[i].tagName === \"FOLDER\") {\n          this.loadEffectElements(effects[i].children);\n        } else if (effects[i].tagName === \"EFFECT\") {\n          var e = new _Effect2.default();\n          e.loadFromXML(effects[i]);\n          this.addEffect(e);\n        } //console.log(effects[i].tagName);\n        //console.log(effects[i].attributes.getNamedItem(\"NAME\").nodeValue);\n\n      }\n    }\n  }, {\n    key: \"clearAll\",\n    value: function clearAll() {\n      this._name = \"\";\n      this._effects = []; // indexed by name\n\n      this._emitters = []; // indexed by name\n\n      this._shapeList = [];\n    }\n  }, {\n    key: \"getShapes\",\n    value: function getShapes() {\n      return this._shapeList;\n    }\n  }, {\n    key: \"getImage\",\n    value: function getImage(index) {\n      return this._shapeList[index];\n    }\n  }, {\n    key: \"getEffect\",\n    value: function getEffect(name) {\n      return this._effects[name];\n    }\n  }, {\n    key: \"getEmitter\",\n    value: function getEmitter(name) {\n      return this._emitters[name];\n    }\n  }, {\n    key: \"addEffect\",\n    value: function addEffect(e) {\n      var name = e.getPath();\n      this._effects[name] = e;\n      var emitters = e.getChildren();\n\n      for (var i = 0; i < e.emitterCount(); i++) {\n        this.addEmitter(emitters[i]);\n      }\n    }\n  }, {\n    key: \"addEmitter\",\n    value: function addEmitter(e) {\n      var name = e.getPath();\n      this._emitters[name] = e;\n      var effects = e.getEffects();\n\n      for (var i = 0; i < effects.length; i++) {\n        this.addEffect(effects[i]);\n      }\n    }\n  }, {\n    key: \"setUpdateFrequency\",\n    value: function setUpdateFrequency(freq) {\n      this._updateFrequency = freq; //  fps\n\n      this._updateTime = 1000.0 / this._updateFrequency;\n      this._currentUpdateTime = this._updateFrequency;\n    }\n  }, {\n    key: \"setLookupFrequency\",\n    value: function setLookupFrequency(freq) {\n      this._lookupFrequency = freq;\n    }\n  }, {\n    key: \"setLookupFrequencyOverTime\",\n    value: function setLookupFrequencyOverTime(freq) {\n      this._lookupFrequencyOverTime = freq;\n    }\n  }, {\n    key: \"getUpdateFrequency\",\n    value: function getUpdateFrequency() {\n      return this._updateFrequency;\n    }\n  }, {\n    key: \"getUpdateTime\",\n    value: function getUpdateTime() {\n      return this._updateTime;\n    }\n  }, {\n    key: \"getCurrentUpdateTime\",\n    value: function getCurrentUpdateTime() {\n      return this._currentUpdateTime;\n    }\n  }, {\n    key: \"getLookupFrequency\",\n    value: function getLookupFrequency() {\n      return this._lookupFrequency;\n    }\n  }, {\n    key: \"getLookupFrequencyOverTime\",\n    value: function getLookupFrequencyOverTime() {\n      return this._lookupFrequencyOverTime;\n    }\n  }]);\n\n  return EffectsLibrary;\n}();\n\n_defineProperty(EffectsLibrary, \"instance\", void 0);\n\n_defineProperty(EffectsLibrary, \"c_particleLimit\", 5000);\n\n_defineProperty(EffectsLibrary, \"globalPercentMin\", 0);\n\n_defineProperty(EffectsLibrary, \"globalPercentMax\", 20.0);\n\n_defineProperty(EffectsLibrary, \"globalPercentSteps\", 100.0);\n\n_defineProperty(EffectsLibrary, \"globalPercentVMin\", 0);\n\n_defineProperty(EffectsLibrary, \"globalPercentVMax\", 10.0);\n\n_defineProperty(EffectsLibrary, \"globalPercentVSteps\", 200.0);\n\n_defineProperty(EffectsLibrary, \"angleMin\", 0);\n\n_defineProperty(EffectsLibrary, \"angleMax\", 1080.0);\n\n_defineProperty(EffectsLibrary, \"angleSteps\", 54.0);\n\n_defineProperty(EffectsLibrary, \"emissionRangeMin\", 0);\n\n_defineProperty(EffectsLibrary, \"emissionRangeMax\", 180.0);\n\n_defineProperty(EffectsLibrary, \"emissionRangeSteps\", 30.0);\n\n_defineProperty(EffectsLibrary, \"dimensionsMin\", 0);\n\n_defineProperty(EffectsLibrary, \"dimensionsMax\", 200.0);\n\n_defineProperty(EffectsLibrary, \"dimensionsSteps\", 40.0);\n\n_defineProperty(EffectsLibrary, \"lifeMin\", 0);\n\n_defineProperty(EffectsLibrary, \"lifeMax\", 100000.0);\n\n_defineProperty(EffectsLibrary, \"lifeSteps\", 200.0);\n\n_defineProperty(EffectsLibrary, \"amountMin\", 0);\n\n_defineProperty(EffectsLibrary, \"amountMax\", 2000);\n\n_defineProperty(EffectsLibrary, \"amountSteps\", 100);\n\n_defineProperty(EffectsLibrary, \"velocityMin\", 0);\n\n_defineProperty(EffectsLibrary, \"velocityMax\", 10000.0);\n\n_defineProperty(EffectsLibrary, \"velocitySteps\", 100.0);\n\n_defineProperty(EffectsLibrary, \"velocityOverTimeMin\", -20.0);\n\n_defineProperty(EffectsLibrary, \"velocityOverTimeMax\", 20.0);\n\n_defineProperty(EffectsLibrary, \"velocityOverTimeSteps\", 200);\n\n_defineProperty(EffectsLibrary, \"weightMin\", -2500.0);\n\n_defineProperty(EffectsLibrary, \"weightMax\", 2500.0);\n\n_defineProperty(EffectsLibrary, \"weightSteps\", 200.0);\n\n_defineProperty(EffectsLibrary, \"weightVariationMin\", 0);\n\n_defineProperty(EffectsLibrary, \"weightVariationMax\", 2500.0);\n\n_defineProperty(EffectsLibrary, \"weightVariationSteps\", 250.0);\n\n_defineProperty(EffectsLibrary, \"spinMin\", -2000.0);\n\n_defineProperty(EffectsLibrary, \"spinMax\", 2000.0);\n\n_defineProperty(EffectsLibrary, \"spinSteps\", 100.0);\n\n_defineProperty(EffectsLibrary, \"spinVariationMin\", 0);\n\n_defineProperty(EffectsLibrary, \"spinVariationMax\", 2000.0);\n\n_defineProperty(EffectsLibrary, \"spinVariationSteps\", 100.0);\n\n_defineProperty(EffectsLibrary, \"spinOverTimeMin\", -20.0);\n\n_defineProperty(EffectsLibrary, \"spinOverTimeMax\", 20.0);\n\n_defineProperty(EffectsLibrary, \"spinOverTimeSteps\", 200.0);\n\n_defineProperty(EffectsLibrary, \"directionOverTimeMin\", 0);\n\n_defineProperty(EffectsLibrary, \"directionOverTimeMax\", 4320.0);\n\n_defineProperty(EffectsLibrary, \"directionOverTimeSteps\", 216.0);\n\n_defineProperty(EffectsLibrary, \"framerateMin\", 0);\n\n_defineProperty(EffectsLibrary, \"framerateMax\", 200.0);\n\n_defineProperty(EffectsLibrary, \"framerateSteps\", 100.0);\n\n_defineProperty(EffectsLibrary, \"maxDirectionVariation\", 22.5);\n\n_defineProperty(EffectsLibrary, \"maxVelocityVariation\", 30.0);\n\n_defineProperty(EffectsLibrary, \"motionVariationInterval\", 30);\n\nvar instance = new EffectsLibrary(); // Object.freeze(instance);\n\nexports.default = instance;\n\n//# sourceURL=webpack:///./src/EffectsLibrary.js?");

/***/ }),

/***/ "./src/Emitter.js":
/*!************************!*\
  !*** ./src/Emitter.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nvar _Effect = __webpack_require__(/*! ./Effect */ \"./src/Effect.js\");\n\nvar _Effect2 = _interopRequireDefault(_Effect);\n\nvar _EffectsLibrary = __webpack_require__(/*! ./EffectsLibrary */ \"./src/EffectsLibrary.js\");\n\nvar _EffectsLibrary2 = _interopRequireDefault(_EffectsLibrary);\n\nvar _Entity2 = __webpack_require__(/*! ./Entity */ \"./src/Entity.js\");\n\nvar _Entity3 = _interopRequireDefault(_Entity2);\n\nvar _Matrix = __webpack_require__(/*! ./Matrix2 */ \"./src/Matrix2.js\");\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nvar _EmitterArray = __webpack_require__(/*! ./EmitterArray */ \"./src/EmitterArray.js\");\n\nvar _EmitterArray2 = _interopRequireDefault(_EmitterArray);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar AngAlign = 0;\nvar AngRandom = 1;\nvar AngSpecify = 2;\nvar g_defaultEmitter = {\n  _currentLife: 0,\n  _uniform: true,\n  _parentEffect: null,\n  _image: null,\n  _handleCenter: false,\n  _angleOffset: 0,\n  _lockedAngle: false,\n  _gx: 0,\n  _gy: 0,\n  _counter: 0,\n  _oldCounter: 0,\n  _angleType: AngAlign,\n  _angleRelative: false,\n  _useEffectEmission: false,\n  _deleted: false,\n  _visible: true,\n  _singleParticle: false,\n  _startedSpawning: false,\n  _spawned: 0,\n  _randomColor: false,\n  _zLayer: 0,\n  _animate: false,\n  _randomStartFrame: false,\n  _animationDirection: 1,\n  _colorRepeat: 0,\n  _alphaRepeat: 0,\n  _dirAlternater: false,\n  _oneShot: false,\n  _particlesRelative: false,\n  _tweenSpawns: false,\n  _once: false,\n  _dying: false,\n  _groupParticles: false,\n  _bypassWeight: false,\n  _bypassSpeed: false,\n  _bypassSpin: false,\n  _bypassDirectionvariation: false,\n  _bypassColor: false,\n  _bRed: false,\n  _bGreen: false,\n  _bBlue: false,\n  _bypassScaleX: false,\n  _bypassScaleY: false,\n  _bypassLifeVariation: false,\n  _bypassFramerate: false,\n  _bypassStretch: false,\n  _bypassSplatter: false,\n  _AABB_ParticleMaxWidth: 0,\n  _AABB_ParticleMaxHeight: 0,\n  _AABB_ParticleMinWidth: 0,\n  _AABB_ParticleMinHeight: 0,\n  _currentLifeVariation: 0,\n  _currentWeight: 0,\n  _currentWeightVariation: 0,\n  _currentSpeed: 0,\n  _currentSpeedVariation: 0,\n  _currentSpin: 0,\n  _currentSpinVariation: 0,\n  _currentDirectionVariation: 0,\n  _currentEmissionAngle: 0,\n  _currentEmissionRange: 0,\n  _currentSizeX: 0,\n  _currentSizeY: 0,\n  _currentSizeXVariation: 0,\n  _currentSizeYVariation: 0,\n  _currentFramerate: 0\n};\n\nvar Emitter =\n/*#__PURE__*/\nfunction (_Entity) {\n  _inherits(Emitter, _Entity);\n\n  function Emitter(other, pm) {\n    var _this;\n\n    _classCallCheck(this, Emitter);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Emitter).call(this, other));\n    _this._effects = [];\n    _this._childrenOwner = false; // the Particles are managing by pool\n\n    _this._matrix = new _Matrix2.default();\n\n    if (other) {\n      for (var key in g_defaultEmitter) {\n        _this[key] = other[key];\n      }\n\n      _this._dob = pm.getCurrentTime();\n\n      _this.setOKtoRender(false);\n\n      _this._arrayOwner = false;\n      _this._children = [];\n\n      for (var i = 0; i < other._effects.length; i++) {\n        _this.addEffect(new _Effect2.default(other._effects[i], pm));\n      }\n\n      _this._cAmount = other._cAmount;\n      _this._cLife = other._cLife;\n      _this._cSizeX = other._cSizeX;\n      _this._cSizeY = other._cSizeY;\n      _this._cBaseSpeed = other._cBaseSpeed;\n      _this._cBaseWeight = other._cBaseWeight;\n      _this._cBaseSpin = other._cBaseSpin;\n      _this._cEmissionAngle = other._cEmissionAngle;\n      _this._cEmissionRange = other._cEmissionRange;\n      _this._cSplatter = other._cSplatter;\n      _this._cVelVariation = other._cVelVariation;\n      _this._cWeightVariation = other._cWeightVariation;\n      _this._cLifeVariation = other._cLifeVariation;\n      _this._cAmountVariation = other._cAmountVariation;\n      _this._cSizeXVariation = other._cSizeXVariation;\n      _this._cSizeYVariation = other._cSizeYVariation;\n      _this._cSpinVariation = other._cSpinVariation;\n      _this._cDirectionVariation = other._cDirectionVariation;\n      _this._cAlpha = other._cAlpha;\n      _this._cR = other._cR;\n      _this._cG = other._cG;\n      _this._cB = other._cB;\n      _this._cScaleX = other._cScaleX;\n      _this._cScaleY = other._cScaleY;\n      _this._cSpin = other._cSpin;\n      _this._cVelocity = other._cVelocity;\n      _this._cWeight = other._cWeight;\n      _this._cDirection = other._cDirection;\n      _this._cDirectionVariationOT = other._cDirectionVariationOT;\n      _this._cFramerate = other._cFramerate;\n      _this._cStretch = other._cStretch;\n      _this._cGlobalVelocity = other._cGlobalVelocity;\n    } else {\n      for (var _key in g_defaultEmitter) {\n        _this[_key] = g_defaultEmitter[_key];\n      }\n\n      _this._arrayOwner = true;\n      _this._cAmount = new _EmitterArray2.default(_EffectsLibrary2.default.amountMin, _EffectsLibrary2.default.amountMax);\n      _this._cLife = new _EmitterArray2.default(_EffectsLibrary2.default.lifeMin, _EffectsLibrary2.default.lifeMax);\n      _this._cSizeX = new _EmitterArray2.default(_EffectsLibrary2.default.dimensionsMin, _EffectsLibrary2.default.dimensionsMax);\n      _this._cSizeY = new _EmitterArray2.default(_EffectsLibrary2.default.dimensionsMin, _EffectsLibrary2.default.dimensionsMax);\n      _this._cBaseSpeed = new _EmitterArray2.default(_EffectsLibrary2.default.velocityMin, _EffectsLibrary2.default.velocityMax);\n      _this._cBaseWeight = new _EmitterArray2.default(_EffectsLibrary2.default.weightMin, _EffectsLibrary2.default.weightMax);\n      _this._cBaseSpin = new _EmitterArray2.default(_EffectsLibrary2.default.spinMin, _EffectsLibrary2.default.spinMax);\n      _this._cEmissionAngle = new _EmitterArray2.default(_EffectsLibrary2.default.angleMin, _EffectsLibrary2.default.angleMax);\n      _this._cEmissionRange = new _EmitterArray2.default(_EffectsLibrary2.default.emissionRangeMin, _EffectsLibrary2.default.emissionRangeMax);\n      _this._cSplatter = new _EmitterArray2.default(_EffectsLibrary2.default.dimensionsMin, _EffectsLibrary2.default.dimensionsMax);\n      _this._cVelVariation = new _EmitterArray2.default(_EffectsLibrary2.default.velocityMin, _EffectsLibrary2.default.velocityMax);\n      _this._cWeightVariation = new _EmitterArray2.default(_EffectsLibrary2.default.weightVariationMin, _EffectsLibrary2.default.weightVariationMax);\n      _this._cLifeVariation = new _EmitterArray2.default(_EffectsLibrary2.default.lifeMin, _EffectsLibrary2.default.lifeMax);\n      _this._cAmountVariation = new _EmitterArray2.default(_EffectsLibrary2.default.amountMin, _EffectsLibrary2.default.amountMax);\n      _this._cSizeXVariation = new _EmitterArray2.default(_EffectsLibrary2.default.dimensionsMin, _EffectsLibrary2.default.dimensionsMax);\n      _this._cSizeYVariation = new _EmitterArray2.default(_EffectsLibrary2.default.dimensionsMin, _EffectsLibrary2.default.dimensionsMax);\n      _this._cSpinVariation = new _EmitterArray2.default(_EffectsLibrary2.default.spinVariationMin, _EffectsLibrary2.default.spinVariationMax);\n      _this._cDirectionVariation = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this._cAlpha = new _EmitterArray2.default(0, 1.0);\n      _this._cR = new _EmitterArray2.default(0, 0);\n      _this._cG = new _EmitterArray2.default(0, 0);\n      _this._cB = new _EmitterArray2.default(0, 0);\n      _this._cScaleX = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this._cScaleY = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this._cSpin = new _EmitterArray2.default(_EffectsLibrary2.default.spinOverTimeMin, _EffectsLibrary2.default.spinOverTimeMax);\n      _this._cVelocity = new _EmitterArray2.default(_EffectsLibrary2.default.velocityOverTimeMin, _EffectsLibrary2.default.velocityOverTimeMax);\n      _this._cWeight = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this._cDirection = new _EmitterArray2.default(_EffectsLibrary2.default.directionOverTimeMin, _EffectsLibrary2.default.directionOverTimeMax);\n      _this._cDirectionVariationOT = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this._cFramerate = new _EmitterArray2.default(_EffectsLibrary2.default.framerateMin, _EffectsLibrary2.default.framerateMax);\n      _this._cStretch = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n      _this._cGlobalVelocity = new _EmitterArray2.default(_EffectsLibrary2.default.globalPercentMin, _EffectsLibrary2.default.globalPercentMax);\n    }\n\n    return _this;\n  }\n\n  _createClass(Emitter, [{\n    key: \"loadFromXML\",\n    value: function loadFromXML(xml, parent) {\n      var x = new _Utils.XMLHelper(xml);\n      this.setHandleX(x.getAttrAsInt(\"HANDLE_X\"));\n      this.setHandleY(x.getAttrAsInt(\"HANDLE_Y\"));\n      this.setBlendMode(x.getAttrAsInt(\"BLENDMODE\"));\n      this.setParticlesRelative(x.getAttrAsBool(\"RELATIVE\"));\n      this.setRandomColor(x.getAttrAsBool(\"RANDOM_COLOR\"));\n      this.setZLayer(x.getAttrAsInt(\"LAYER\"));\n      this.setSingleParticle(x.getAttrAsBool(\"SINGLE_PARTICLE\"));\n      this.setName(x.getAttr(\"NAME\"));\n      this.setAnimate(x.getAttrAsBool(\"ANIMATE\"));\n      this.setOnce(x.getAttrAsBool(\"ANIMATE_ONCE\"));\n      this.setCurrentFrame(x.getAttrAsFloat(\"FRAME\"));\n      this.setRandomStartFrame(x.getAttrAsBool(\"RANDOM_START_FRAME\"));\n      this.setAnimationDirection(x.getAttrAsInt(\"ANIMATION_DIRECTION\"));\n      this.setUniform(x.getAttrAsBool(\"UNIFORM\"));\n      this.setAngleType(x.getAttrAsInt(\"ANGLE_TYPE\"));\n      this.setAngleOffset(x.getAttrAsInt(\"ANGLE_OFFSET\"));\n      this.setLockAngle(x.getAttrAsBool(\"LOCK_ANGLE\"));\n      this.setAngleRelative(x.getAttrAsBool(\"ANGLE_RELATIVE\"));\n      this.setUseEffectEmission(x.getAttrAsBool(\"USE_EFFECT_EMISSION\"));\n      this.setColorRepeat(x.getAttrAsInt(\"COLOR_REPEAT\"));\n      this.setAlphaRepeat(x.getAttrAsInt(\"ALPHA_REPEAT\"));\n      this.setOneShot(x.getAttrAsBool(\"ONE_SHOT\"));\n      this.setHandleCenter(x.getAttrAsBool(\"HANDLE_CENTERED\"));\n      this.setGroupParticles(x.getAttrAsBool(\"GROUP_PARTICLES\")); // ?\n\n      if (this.getAnimationDirection() === 0) this.setAnimationDirection(1);\n      this.setParentEffect(parent);\n      var path = parent.getPath() + \"/\" + this.getName();\n      this.setPath(path);\n      var imgNode = xml.getElementsByTagName(\"SHAPE_INDEX\")[0];\n      this.setImage(parseInt(imgNode.innerHTML));\n      if (x.hasChildAttr(\"ANGLE_TYPE\")) this.setAngleType(x.getChildAttrAsInt(\"ANGLE_TYPE\", \"VALUE\"));\n      if (x.hasChildAttr(\"ANGLE_OFFSET\")) this.setAngleOffset(x.getChildAttrAsInt(\"ANGLE_OFFSET\", \"VALUE\"));\n      if (x.hasChildAttr(\"LOCKED_ANGLE\")) this.setLockAngle(x.getChildAttrAsBool(\"LOCKED_ANGLE\", \"VALUE\"));\n      if (x.hasChildAttr(\"ANGLE_RELATIVE\")) this.setAngleRelative(x.getChildAttrAsBool(\"ANGLE_RELATIVE\", \"VALUE\"));\n      if (x.hasChildAttr(\"USE_EFFECT_EMISSION\")) this.setUseEffectEmission(x.getChildAttrAsBool(\"USE_EFFECT_EMISSION\", \"VALUE\"));\n      if (x.hasChildAttr(\"COLOR_REPEAT\")) this.setColorRepeat(x.getChildAttrAsInt(\"COLOR_REPEAT\", \"VALUE\"));\n      if (x.hasChildAttr(\"ALPHA_REPEAT\")) this.setAlphaRepeat(x.getChildAttrAsInt(\"ALPHA_REPEAT\", \"VALUE\"));\n      if (x.hasChildAttr(\"ONE_SHOT\")) this.setOneShot(x.getChildAttrAsBool(\"ONE_SHOT\", \"VALUE\"));\n      if (x.hasChildAttr(\"HANDLE_CENTERED\")) this.setHandleCenter(x.getChildAttrAsBool(\"HANDLE_CENTERED\", \"VALUE\"));\n      this.readAttribute(xml, this._cLife, \"LIFE\");\n      this.readAttribute(xml, this._cAmount, \"AMOUNT\");\n      this.readAttribute(xml, this._cBaseSpeed, \"BASE_SPEED\");\n      this.readAttribute(xml, this._cBaseWeight, \"BASE_WEIGHT\");\n      this.readAttribute(xml, this._cSizeX, \"BASE_SIZE_X\");\n      this.readAttribute(xml, this._cSizeY, \"BASE_SIZE_Y\");\n      this.readAttribute(xml, this._cBaseSpin, \"BASE_SPIN\");\n      this.readAttribute(xml, this._cSplatter, \"SPLATTER\");\n      this.readAttribute(xml, this._cLifeVariation, \"LIFE_VARIATION\");\n      this.readAttribute(xml, this._cAmountVariation, \"AMOUNT_VARIATION\");\n      this.readAttribute(xml, this._cVelVariation, \"VELOCITY_VARIATION\");\n      this.readAttribute(xml, this._cWeightVariation, \"WEIGHT_VARIATION\");\n      this.readAttribute(xml, this._cSizeXVariation, \"SIZE_X_VARIATION\");\n      this.readAttribute(xml, this._cSizeYVariation, \"SIZE_Y_VARIATION\");\n      this.readAttribute(xml, this._cSpinVariation, \"SPIN_VARIATION\");\n      this.readAttribute(xml, this._cDirectionVariation, \"DIRECTION_VARIATION\");\n      this.readAttribute(xml, this._cAlpha, \"ALPHA_OVERTIME\");\n      this.readAttribute(xml, this._cVelocity, \"VELOCITY_OVERTIME\");\n      this.readAttribute(xml, this._cWeight, \"WEIGHT_OVERTIME\");\n      this.readAttribute(xml, this._cScaleX, \"SCALE_X_OVERTIME\");\n      this.readAttribute(xml, this._cScaleY, \"SCALE_Y_OVERTIME\");\n      this.readAttribute(xml, this._cSpin, \"SPIN_OVERTIME\");\n      this.readAttribute(xml, this._cDirection, \"DIRECTION\");\n      this.readAttribute(xml, this._cDirectionVariationOT, \"DIRECTION_VARIATIONOT\");\n      this.readAttribute(xml, this._cFramerate, \"FRAMERATE_OVERTIME\");\n      this.readAttribute(xml, this._cStretch, \"STRETCH_OVERTIME\");\n      this.readAttribute(xml, this._cR, \"RED_OVERTIME\");\n      this.readAttribute(xml, this._cG, \"GREEN_OVERTIME\");\n      this.readAttribute(xml, this._cB, \"BLUE_OVERTIME\");\n      this.readAttribute(xml, this._cGlobalVelocity, \"GLOBAL_VELOCITY\");\n      this.readAttribute(xml, this._cEmissionAngle, \"EMISSION_ANGLE\");\n      this.readAttribute(xml, this._cEmissionRange, \"EMISSION_RANGE\"); // This seems suspect? only one child?\n\n      var childNode = xml.getElementsByTagName(\"EFFECT\")[0];\n\n      if (childNode) {\n        var e = new _Effect2.default();\n        e.loadFromXML(childNode); //e.CompileAll();\n\n        e.setParentEmitter(this);\n        this.addEffect(e);\n      }\n    }\n  }, {\n    key: \"readAttribute\",\n    value: function readAttribute(xml, emitArray, tag) {\n      (0, _Utils.forEachXMLChild)(xml, tag, function (n) {\n        var attr = emitArray.add(parseFloat((0, _Utils.getNodeAttrValue)(n, \"FRAME\")), parseFloat((0, _Utils.getNodeAttrValue)(n, \"VALUE\")));\n        attr.loadFromXML(n.getElementsByTagName(\"CURVE\")[0]);\n      });\n    }\n  }, {\n    key: \"sortAll\",\n    value: function sortAll() {\n      this._cR.sort();\n\n      this._cG.sort();\n\n      this._cB.sort();\n\n      this._cBaseSpin.sort();\n\n      this._cSpin.sort();\n\n      this._cSpinVariation.sort();\n\n      this._cVelocity.sort();\n\n      this._cBaseSpeed.sort();\n\n      this._cVelVariation.sort();\n\n      this._cAlpha.sort();\n\n      this._cSizeX.sort();\n\n      this._cSizeY.sort();\n\n      this._cScaleX.sort();\n\n      this._cScaleY.sort();\n\n      this._cSizeXVariation.sort();\n\n      this._cSizeYVariation.sort();\n\n      this._cLifeVariation.sort();\n\n      this._cLife.sort();\n\n      this._cAmount.sort();\n\n      this._cAmountVariation.sort();\n\n      this._cEmissionAngle.sort();\n\n      this._cEmissionRange.sort();\n\n      this._cFramerate.sort();\n\n      this._cStretch.sort();\n\n      this._cGlobalVelocity.sort();\n    }\n  }, {\n    key: \"showAll\",\n    value: function showAll() {\n      this.setVisible(true);\n\n      for (var i = 0; i < this._effects.length; i++) {\n        this._effects[i].showAll();\n      }\n    }\n  }, {\n    key: \"hideAll\",\n    value: function hideAll() {\n      this.setVisible(false);\n\n      for (var i = 0; i < this._effects.length; i++) {\n        this._effects[i].hideAll();\n      }\n    }\n  }, {\n    key: \"addEffect\",\n    value: function addEffect(effect) {\n      this._effects.push(effect);\n    }\n  }, {\n    key: \"setParentEffect\",\n    value: function setParentEffect(parent) {\n      this._parentEffect = parent;\n    }\n  }, {\n    key: \"setImage\",\n    value: function setImage(imageIndex) {\n      var image = _EffectsLibrary2.default.getImage(imageIndex);\n\n      this._image = image;\n      this._AABB_ParticleMaxWidth = image.getWidth() * 0.5;\n      this._AABB_ParticleMaxHeight = image.getHeight() * 0.5;\n      this._AABB_ParticleMinWidth = image.getWidth() * -0.5;\n      this._AABB_ParticleMinHeight = image.getHeight() * -0.5;\n    }\n  }, {\n    key: \"setAngleOffset\",\n    value: function setAngleOffset(offset) {\n      this._angleOffset = offset;\n    }\n  }, {\n    key: \"setUniform\",\n    value: function setUniform(value) {\n      this._uniform = value;\n    }\n  }, {\n    key: \"setAngleType\",\n    value: function setAngleType(angleType) {\n      this._angleType = angleType;\n    }\n  }, {\n    key: \"setUseEffectEmission\",\n    value: function setUseEffectEmission(value) {\n      this._useEffectEmission = value;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(value) {\n      this._visible = value;\n    }\n  }, {\n    key: \"setSingleParticle\",\n    value: function setSingleParticle(value) {\n      this._singleParticle = value;\n    }\n  }, {\n    key: \"setRandomColor\",\n    value: function setRandomColor(value) {\n      this._randomColor = value;\n    }\n  }, {\n    key: \"setZLayer\",\n    value: function setZLayer(zLayer) {\n      this._zLayer = zLayer;\n    }\n  }, {\n    key: \"setAnimate\",\n    value: function setAnimate(value) {\n      this._animate = value;\n    }\n  }, {\n    key: \"setRandomStartFrame\",\n    value: function setRandomStartFrame(value) {\n      this._randomStartFrame = value;\n    }\n  }, {\n    key: \"setAnimationDirection\",\n    value: function setAnimationDirection(direction) {\n      this._animationDirection = direction;\n    }\n  }, {\n    key: \"setColorRepeat\",\n    value: function setColorRepeat(repeat) {\n      this._colorRepeat = repeat;\n    }\n  }, {\n    key: \"setAlphaRepeat\",\n    value: function setAlphaRepeat(repeat) {\n      this._alphaRepeat = repeat;\n    }\n  }, {\n    key: \"setOneShot\",\n    value: function setOneShot(value) {\n      this._oneShot = value;\n    }\n  }, {\n    key: \"setHandleCenter\",\n    value: function setHandleCenter(value) {\n      this._handleCenter = value;\n    }\n  }, {\n    key: \"setParticlesRelative\",\n    value: function setParticlesRelative(value) {\n      this._particlesRelative = value;\n    }\n  }, {\n    key: \"setTweenSpawns\",\n    value: function setTweenSpawns(value) {\n      this._tweenSpawns = value;\n    }\n  }, {\n    key: \"setLockAngle\",\n    value: function setLockAngle(value) {\n      this._lockedAngle = value;\n    }\n  }, {\n    key: \"setAngleRelative\",\n    value: function setAngleRelative(value) {\n      this._angleRelative = value;\n    }\n  }, {\n    key: \"setOnce\",\n    value: function setOnce(value) {\n      this._once = value;\n    }\n  }, {\n    key: \"setGroupParticles\",\n    value: function setGroupParticles(value) {\n      this._groupParticles = value;\n    }\n  }, {\n    key: \"getParentEffect\",\n    value: function getParentEffect() {\n      return this._parentEffect;\n    }\n  }, {\n    key: \"getImage\",\n    value: function getImage() {\n      return this._image;\n    }\n  }, {\n    key: \"getAngleOffset\",\n    value: function getAngleOffset() {\n      return this._angleOffset;\n    }\n  }, {\n    key: \"isUniform\",\n    value: function isUniform() {\n      return this._uniform;\n    }\n  }, {\n    key: \"getAngleType\",\n    value: function getAngleType() {\n      return this._angleType;\n    }\n  }, {\n    key: \"isUseEffectEmmision\",\n    value: function isUseEffectEmmision() {\n      return this._useEffectEmission;\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this._visible;\n    }\n  }, {\n    key: \"isSingleParticle\",\n    value: function isSingleParticle() {\n      return this._singleParticle;\n    }\n  }, {\n    key: \"isRandomColor\",\n    value: function isRandomColor() {\n      return this._randomColor;\n    }\n  }, {\n    key: \"getZLayer\",\n    value: function getZLayer() {\n      return this._zLayer;\n    }\n  }, {\n    key: \"isAnimate\",\n    value: function isAnimate() {\n      return this._animate;\n    }\n  }, {\n    key: \"isRandomStartFrame\",\n    value: function isRandomStartFrame() {\n      return this._randomStartFrame;\n    }\n  }, {\n    key: \"getAnimationDirection\",\n    value: function getAnimationDirection() {\n      return this._animationDirection;\n    }\n  }, {\n    key: \"getColorRepeat\",\n    value: function getColorRepeat() {\n      return this._colorRepeat;\n    }\n  }, {\n    key: \"getAlphaRepeat\",\n    value: function getAlphaRepeat() {\n      return this._alphaRepeat;\n    }\n  }, {\n    key: \"isOneShot\",\n    value: function isOneShot() {\n      return this._oneShot;\n    }\n  }, {\n    key: \"isHandleCenter\",\n    value: function isHandleCenter() {\n      return this._handleCenter;\n    }\n  }, {\n    key: \"isParticlesRelative\",\n    value: function isParticlesRelative() {\n      return this._particlesRelative;\n    }\n  }, {\n    key: \"isTweenSpawns\",\n    value: function isTweenSpawns() {\n      return this._tweenSpawns;\n    }\n  }, {\n    key: \"isLockAngle\",\n    value: function isLockAngle() {\n      return this._lockedAngle;\n    }\n  }, {\n    key: \"isAngleRelative\",\n    value: function isAngleRelative() {\n      return this._angleRelative;\n    }\n  }, {\n    key: \"isOnce\",\n    value: function isOnce() {\n      return this._once;\n    }\n  }, {\n    key: \"isGroupParticles\",\n    value: function isGroupParticles() {\n      return this._groupParticles;\n    }\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      return this._path;\n    }\n  }, {\n    key: \"setRadiusCalculate\",\n    value: function setRadiusCalculate(value) {\n      this._radiusCalculate = value;\n\n      for (var i = 0; i < this._children.length; i++) {\n        this._children[i].setRadiusCalculate(value);\n      }\n\n      for (var _i = 0; _i < this._effects.length; _i++) {\n        this._effects[_i].setRadiusCalculate(value);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(releaseChildren) {\n      this._parentEffect = null;\n      this._image = null;\n\n      for (var i = 0; i < this._effects.length; i++) {\n        this._effects[i].destroy();\n      }\n\n      this._effects = [];\n\n      _get(_getPrototypeOf(Emitter.prototype), \"destroy\", this).call(this, false); // Emitter.$superp.Destroy.call(this, false);\n\n    }\n  }, {\n    key: \"changeDoB\",\n    value: function changeDoB(dob) {\n      this._dob = dob;\n\n      for (var i = 0; i < this._effects.length; i++) {\n        this._effects[i].changeDoB(dob);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.capture();\n      var radians = this._angle / 180.0 * _Utils.M_PI;\n\n      this._matrix.set(Math.cos(radians), Math.sin(radians), -Math.sin(radians), Math.cos(radians));\n\n      if (this._parent && this._relative) {\n        this.setZ(this._parent.getZ());\n\n        this._matrix.transformSelf(this._parent.getMatrix());\n\n        var rotvec = this._parent.getMatrix().transformVector(this._x, this._y);\n\n        this._wx = this._parent.getWX() + rotvec.x * this._z;\n        this._wy = this._parent.getWY() + rotvec.y * this._z;\n        this._relativeAngle = this._parent.getRelativeAngle() + this._angle;\n      } else {\n        this._wx = this._x;\n        this._wy = this._y;\n      }\n\n      if (!this._tweenSpawns) {\n        this.capture();\n        this._tweenSpawns = true;\n      }\n\n      this._dying = this._parentEffect.isDying();\n\n      _get(_getPrototypeOf(Emitter.prototype), \"updateBoundingBox\", this).call(this);\n\n      if (this._radiusCalculate) _get(_getPrototypeOf(Emitter.prototype), \"updateEntityRadius\", this).call(this);\n      this.updateChildren();\n\n      if (!this._dead && !this._dying) {\n        if (this._visible && this._parentEffect.getParticleManager().isSpawningAllowed()) this.updateSpawns();\n      } else {\n        if (this._children.length === 0) {\n          this.destroy();\n          return false;\n        } else {\n          this.killChildren();\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"updateSpawns\",\n    value: function updateSpawns() {\n      var eSingle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var intCounter;\n      var qty;\n      var er;\n      var e;\n      var parentEffect = this._parentEffect;\n      var curFrame = parentEffect.getCurrentEffectFrame();\n      var pm = parentEffect.getParticleManager();\n      var a1 = this.getEmitterAmount(curFrame);\n      var a2 = (0, _Utils.random)(this.getEmitterAmountVariation(curFrame));\n      var a3 = parentEffect.getCurrentAmount();\n      var a4 = pm.getGlobalAmountScale();\n      qty = (this.getEmitterAmount(curFrame) + (0, _Utils.random)(this.getEmitterAmountVariation(curFrame))) * parentEffect.getCurrentAmount() * pm.getGlobalAmountScale() / _EffectsLibrary2.default.getUpdateFrequency();\n\n      if (!this._singleParticle) {\n        this._counter += qty;\n      }\n\n      intCounter = Math.floor(this._counter);\n\n      if (intCounter >= 1 || this._singleParticle && !this._startedSpawning) {\n        if (!this._startedSpawning && this._singleParticle) {\n          switch (parentEffect.getClass()) {\n            case _Effect.TypePoint:\n              intCounter = 1;\n              break;\n\n            case _Effect.TypeArea:\n              intCounter = parentEffect.getMGX() * parentEffect.getMGY();\n              break;\n\n            case _Effect.TypeLine:\n            case _Effect.TypeEllipse:\n              intCounter = parentEffect.getMGX();\n              break;\n          }\n        } else if (this._singleParticle && this._startedSpawning) {\n          intCounter = 0;\n        } // preload attributes\n\n\n        this._currentLife = this.getEmitterLife(curFrame) * parentEffect.getCurrentLife();\n\n        if (!this._bypassWeight) {\n          this._currentWeight = this.getEmitterBaseWeight(curFrame);\n          this._currentWeightVariation = this.getEmitterWeightVariation(curFrame);\n        }\n\n        if (!this._bypassSpeed) {\n          this._currentSpeed = this.getEmitterBaseSpeed(curFrame);\n          this._currentSpeedVariation = this.getEmitterVelVariation(curFrame);\n        }\n\n        if (!this._bypassSpin) {\n          this._currentSpin = this.getEmitterBaseSpin(curFrame);\n          this._currentSpinVariation = this.getEmitterSpinVariation(curFrame);\n        }\n\n        this._currentDirectionVariation = this.getEmitterDirectionVariation(curFrame);\n\n        if (this._useEffectEmission) {\n          er = parentEffect.getCurrentEmissionRange();\n          this._currentEmissionAngle = parentEffect.getCurrentEmissionAngle();\n        } else {\n          er = this.getEmitterEmissionRange(curFrame);\n          this._currentEmissionAngle = this.getEmitterEmissionAngle(curFrame);\n        }\n\n        this._currentLifeVariation = this.getEmitterLifeVariation(curFrame);\n        this._currentSizeX = this.getEmitterSizeX(curFrame);\n        this._currentSizeY = this.getEmitterSizeY(curFrame);\n        this._currentSizeXVariation = this.getEmitterSizeXVariation(curFrame);\n        this._currentSizeYVariation = this.getEmitterSizeYVariation(curFrame); // ------------------------------\n\n        for (var c = 1; c <= intCounter; ++c) {\n          this._startedSpawning = true;\n\n          if (!eSingle) {\n            e = pm.grabParticle(parentEffect, this._groupParticles, this._zLayer);\n          } else {\n            e = eSingle;\n          }\n\n          if (e) {\n            // -----Link to its emitter and assign the control source (which is this emitter)----\n            e.setEmitter(this);\n            e.setParent(this);\n            e.setParticleManager(pm);\n            e.setEffectLayer(parentEffect.getEffectLayer()); // ----------------------------------------------------\n\n            e.setDoB(pm.getCurrentTime());\n\n            if (parentEffect.getTraverseEdge() && parentEffect.getClass() == _Effect.TypeLine) {\n              this._particlesRelative = true;\n            }\n\n            e.setRelative(this._particlesRelative);\n\n            switch (parentEffect.getClass()) {\n              case _Effect.TypePoint:\n                if (e.isRelative()) {\n                  e.setX(0 - parentEffect.getHandleX());\n                  e.setY(0 - parentEffect.getHandleY());\n                } else {\n                  var tween = c / intCounter;\n\n                  if (parentEffect.getHandleCenter() || parentEffect.getHandleX() + parentEffect.getHandleY() === 0) {\n                    // @dan already set? tween = c / intCounter;\n                    e.setX((0, _Utils.lerp)(this._oldWX, this._wx, tween));\n                    e.setY((0, _Utils.lerp)(this._oldWY, this._wy, tween));\n                    e.setWX(e.getX() - parentEffect.getHandleX() * this._z);\n                    e.setWY(e.getY() - parentEffect.getHandleY() * this._z);\n                  } else {\n                    e.setX(0 - parentEffect.getHandleX());\n                    e.setY(0 - parentEffect.getHandleY());\n\n                    var rotvec = this._parent.getMatrix().transformVector(e.getX(), e.getY());\n\n                    e.setX((0, _Utils.lerp)(this._oldWX, this._wx, tween) + rotvec.x);\n                    e.setY((0, _Utils.lerp)(this._oldWY, this._wy, tween) + rotvec.y);\n                    e.setWX(e.getX() * this._z);\n                    e.setWY(e.getY() * this._z);\n                  }\n                }\n\n                break;\n\n              case _Effect.TypeArea:\n                if (parentEffect.getEmitAtPoints()) {\n                  if (parentEffect._spawnDirection == -1) {\n                    this._gx += parentEffect._spawnDirection;\n\n                    if (this._gx < 0) {\n                      this._gx = parentEffect.getMGX() - 1;\n                      this._gy += parentEffect._spawnDirection;\n                      if (this._gy < 0) this._gy = parentEffect.getMGY() - 1;\n                    }\n                  }\n\n                  if (parentEffect.getMGX() > 1) {\n                    e.setX(this._gx / (parentEffect.getMGX() - 1) * parentEffect.getCurrentWidth() - parentEffect.getHandleX());\n                  } else {\n                    e.setX(-parentEffect.getHandleX());\n                  }\n\n                  if (parentEffect.getMGY() > 1) {\n                    e.setY(this._gy / (parentEffect.getMGY() - 1) * parentEffect.getCurrentHeight() - parentEffect.getHandleY());\n                  } else {\n                    e.setY(-parentEffect.getHandleY());\n                  }\n\n                  if (parentEffect._spawnDirection == 1) {\n                    this._gx += parentEffect._spawnDirection;\n\n                    if (this._gx >= parentEffect.getMGX()) {\n                      this._gx = 0;\n                      this._gy += parentEffect._spawnDirection;\n                      if (this._gy >= parentEffect.getMGY()) this._gy = 0;\n                    }\n                  }\n                } else {\n                  e.setX((0, _Utils.random)(parentEffect.getCurrentWidth()) - parentEffect.getHandleX());\n                  e.setY((0, _Utils.random)(parentEffect.getCurrentHeight()) - parentEffect.getHandleY());\n                }\n\n                if (!e.isRelative()) {\n                  var parent = this._parent;\n\n                  var _rotvec = parent.getMatrix().transformVector(e.getX(), e.getY());\n\n                  e.setX(parent.getWX() + _rotvec.x * this._z);\n                  e.setY(parent.getWY() + _rotvec.y * this._z);\n                }\n\n                break;\n\n              case _Effect.TypeEllipse:\n                {\n                  var tx = parentEffect.getCurrentWidth() / 2.0;\n                  var ty = parentEffect.getCurrentHeight() / 2.0;\n                  var th = 0;\n\n                  if (parentEffect.getEmitAtPoints()) {\n                    if (parentEffect.getMGX() === 0) parentEffect.SetMGX(1);\n                    this._gx += parentEffect._spawnDirection;\n\n                    if (this._gx >= parentEffect.getMGX()) {\n                      this._gx = 0;\n                    } else if (this._gx < 0) {\n                      this._gx = parentEffect.getMGX() - 1;\n                    }\n\n                    th = this._gx * (parentEffect.getEllipseArc() / parentEffect.getMGX()) + parentEffect.getEllipseOffset();\n                  } else {\n                    th = (0, _Utils.random)(parentEffect.getEllipseArc()) + parentEffect.getEllipseOffset();\n                  }\n\n                  e.setX(Math.cos(th / 180.0 * _Utils.M_PI) * tx - parentEffect.getHandleX() + tx);\n                  e.setY(-Math.sin(th / 180.0 * _Utils.M_PI) * ty - parentEffect.getHandleY() + ty);\n\n                  if (!e.isRelative()) {\n                    var _rotvec2 = this._parent.getMatrix().transformVector(e.getX(), e.getY());\n\n                    e.setX(this._parent.getWX() + _rotvec2.x * this._z);\n                    e.setY(this._parent.getWY() + _rotvec2.y * this._z);\n                  }\n                }\n                break;\n\n              case _Effect.TypeLine:\n                if (!parentEffect.getTraverseEdge()) {\n                  if (parentEffect.getEmitAtPoints()) {\n                    if (parentEffect._spawnDirection == -1) {\n                      this._gx += parentEffect._spawnDirection;\n                      if (this._gx < 0) this._gx = parentEffect.getMGX() - 1;\n                    }\n\n                    if (parentEffect.getMGX() > 1) {\n                      e.setX(this._gx / (parentEffect.getMGX() - 1) * parentEffect.getCurrentWidth() - parentEffect.getHandleX());\n                    } else {\n                      e.setX(-parentEffect.getHandleX());\n                    }\n\n                    e.setY(-parentEffect.getHandleY());\n\n                    if (parentEffect._spawnDirection == 1) {\n                      this._gx += parentEffect._spawnDirection;\n                      if (this._gx >= parentEffect.getMGX()) this._gx = 0;\n                    }\n                  } else {\n                    e.setX((0, _Utils.random)(parentEffect.getCurrentWidth()) - parentEffect.getHandleX());\n                    e.setY(-parentEffect.getHandleY());\n                  }\n                } else {\n                  if (parentEffect._distanceSetByLife) {\n                    e.setX(-parentEffect.getHandleX());\n                    e.setY(-parentEffect.getHandleY());\n                  } else {\n                    if (parentEffect.getEmitAtPoints()) {\n                      if (parentEffect._spawnDirection == -1) {\n                        this._gx += parentEffect._spawnDirection;\n                        if (this._gx < 0) this._gx = parentEffect.getMGX() - 1;\n                      }\n\n                      if (parentEffect.getMGX() > 1) {\n                        e.setX(this._gx / (parentEffect.getMGX() - 1) * parentEffect.getCurrentWidth() - parentEffect.getHandleX());\n                      } else {\n                        e.setX(-parentEffect.getHandleX());\n                      }\n\n                      e.setY(-parentEffect.getHandleY());\n\n                      if (parentEffect._spawnDirection == 1) {\n                        this._gx += parentEffect._spawnDirection;\n                        if (this._gx >= parentEffect.getMGX()) this._gx = 0;\n                      }\n                    } else {\n                      e.setX((0, _Utils.random)(parentEffect.getCurrentWidth()) - parentEffect.getHandleX());\n                      e.setY(-parentEffect.getHandleY());\n                    }\n                  }\n                } // rotate\n\n\n                if (!e.isRelative()) {\n                  var _rotvec3 = this._parent.getMatrix().transformVector(e.getX(), e.getY());\n\n                  e.setX(this._parent.getWX() + _rotvec3.x * this._z);\n                  e.setY(this._parent.getWY() + _rotvec3.y * this._z);\n                }\n\n                break;\n            } // set the zoom level\n\n\n            e.setZ(this._z); // set up the image\n\n            e.setAvatar(this._image);\n            e.setHandleX(this._handleX);\n            e.setHandleY(this._handleY);\n            e.setAutocenter(this._handleCenter); // set lifetime properties\n\n            e.setLifeTime(this._currentLife + (0, _Utils.randomBetween)(-this._currentLifeVariation, this._currentLifeVariation) * parentEffect.getCurrentLife()); // speed\n\n            e.setSpeedVecX(0);\n            e.setSpeedVecY(0);\n\n            if (!this._bypassSpeed) {\n              e.setSpeed(this._cVelocity.get(0));\n              e.setVelVariation((0, _Utils.randomBetween)(-this._currentSpeedVariation, this._currentSpeedVariation));\n              e.setBaseSpeed((this._currentSpeed + e.getVelVariation()) * parentEffect.getCurrentVelocity());\n              e.setSpeed(this._cVelocity.get(0) * e.getBaseSpeed() * this._cGlobalVelocity.get(0));\n            } else {\n              e.setSpeed(0);\n            } // size\n\n\n            e.setGSizeX(parentEffect.getCurrentSizeX());\n            e.setGSizeY(parentEffect.getCurrentSizeY()); // width\n\n            var scaleTemp = this._cScaleX.get(0);\n\n            var sizeTemp = 0;\n            e.setScaleVariationX((0, _Utils.random)(this._currentSizeXVariation));\n            e.setWidth(e.getScaleVariationX() + this._currentSizeX);\n\n            if (scaleTemp !== 0) {\n              sizeTemp = e.getWidth() / this._image.getWidth() * scaleTemp * e.getGSizeX();\n            }\n\n            e.setScaleX(sizeTemp);\n\n            if (this._uniform) {\n              // height\n              e.setScaleY(sizeTemp);\n\n              if (!this._bypassStretch) {\n                e.setScaleY(this.getEmitterScaleX(0) * e.getGSizeX() * (e.getWidth() + Math.abs(e.getSpeed()) * this.getEmitterStretch(0, 0) * parentEffect.getCurrentStretch()) / this._image.getWidth());\n                if (e.getScaleY() < e.getScaleX()) e.setScaleY(e.getScaleX());\n              }\n\n              e.setWidthHeightAABB(this._AABB_ParticleMinWidth, this._AABB_ParticleMaxWidth, this._AABB_ParticleMinWidth, this._AABB_ParticleMaxWidth);\n            } else {\n              // height\n              scaleTemp = this.getEmitterScaleY(0);\n              sizeTemp = 0;\n              e.setScaleVariationY((0, _Utils.random)(this._currentSizeYVariation));\n              e.setHeight(e.getScaleVariationY() + this._currentSizeY);\n\n              if (scaleTemp !== 0) {\n                sizeTemp = e.getHeight() / this._image.getHeight() * scaleTemp * e.getGSizeY();\n              }\n\n              e.setScaleY(sizeTemp);\n\n              if (!this._bypassStretch && e.getSpeed() !== 0) {\n                e.setScaleY(this.getEmitterScaleY(0) * e.getGSizeY() * (e.getHeight() + Math.abs(e.getSpeed()) * this.getEmitterStretch(0) * parentEffect.getCurrentStretch()) / this._image.getHeight());\n                if (e.getScaleY() < e.getScaleX()) e.setScaleY(e.getScaleX());\n              }\n\n              e.setWidthHeightAABB(this._AABB_ParticleMinWidth, this._AABB_ParticleMaxWidth, this._AABB_ParticleMinHeight, this._AABB_ParticleMaxHeight);\n            } // splatter\n\n\n            if (!this._bypassSplatter) {\n              var splatterTemp = this.getEmitterSplatter(curFrame);\n              var splatX = (0, _Utils.randomBetween)(-splatterTemp, splatterTemp);\n              var splatY = (0, _Utils.randomBetween)(-splatterTemp, splatterTemp);\n\n              while ((0, _Utils.getDistance2D)(0, 0, splatX, splatY) >= splatterTemp && splatterTemp > 0) {\n                splatX = (0, _Utils.randomBetween)(-splatterTemp, splatterTemp);\n                splatY = (0, _Utils.randomBetween)(-splatterTemp, splatterTemp);\n              }\n\n              if (this._z == 1 || e.isRelative()) {\n                e.move(splatX, splatY);\n              } else {\n                e.move(splatX * this._z, splatY * this._z);\n              }\n            } // rotation and direction of travel settings\n\n\n            e.miniUpdate();\n\n            if (parentEffect.getTraverseEdge() && parentEffect.getClass() == _Effect.TypeLine) {\n              e.setDirectionLocked(true);\n              e.setEntityDirection(90.0);\n            } else {\n              if (parentEffect.getClass() != _Effect.TypePoint) {\n                if (!this._bypassSpeed || this._angleType == AngAlign) {\n                  e.setEmissionAngle(this._currentEmissionAngle + (0, _Utils.randomBetween)(-er, er));\n\n                  switch (parentEffect.getEmissionType()) {\n                    case _Effect.EmInwards:\n                      if (e.isRelative()) e.setEmissionAngle(e.getEmissionAngle() + (0, _Utils.getDirection)(e.getX(), e.getY(), 0, 0));else e.setEmissionAngle(e.getEmissionAngle() + (0, _Utils.getDirection)(e.getWX(), e.getWY(), e.getParent().getWX(), e.getParent().getWY()));\n                      break;\n\n                    case _Effect.EmOutwards:\n                      if (e.isRelative()) e.setEmissionAngle(e.getEmissionAngle() + (0, _Utils.getDirection)(0, 0, e.getX(), e.getY()));else e.setEmissionAngle(e.getEmissionAngle() + (0, _Utils.getDirection)(e.getParent().getWX(), e.getParent().getWY(), e.getWX(), e.getWY()));\n                      break;\n\n                    case _Effect.EmInAndOut:\n                      if (this._dirAlternater) {\n                        if (e.isRelative()) e.setEmissionAngle(e.getEmissionAngle() + (0, _Utils.getDirection)(0, 0, e.getX(), e.getY()));else e.setEmissionAngle(e.getEmissionAngle() + (0, _Utils.getDirection)(e.getParent().getWX(), e.getParent().getWY(), e.getWX(), e.getWY()));\n                      } else {\n                        if (e.isRelative()) e.setEmissionAngle(e.getEmissionAngle() + (0, _Utils.getDirection)(e.getX(), e.getY(), 0, 0));else e.setEmissionAngle(e.getEmissionAngle() + (0, _Utils.getDirection)(e.getWX(), e.getWY(), e.getParent().getWX(), e.getParent().getWY()));\n                      }\n\n                      this._dirAlternater = !this._dirAlternater;\n                      break;\n\n                    case _Effect.EmSpecified:\n                      // nothing\n                      break;\n                  }\n                }\n              } else {\n                e.setEmissionAngle(this._currentEmissionAngle + (0, _Utils.randomBetween)(-er, er));\n              }\n\n              if (!this._bypassDirectionvariation) {\n                e.setDirectionVairation(this._currentDirectionVariation);\n                var dv = e.getDirectionVariation() * this.getEmitterDirectionVariationOt(0);\n                e.setEntityDirection(e.getEmissionAngle() + this.getEmitterDirection(0) + (0, _Utils.randomBetween)(-dv, dv));\n              } else {\n                e.setEntityDirection(e.getEmissionAngle() + this.getEmitterDirection(0));\n              }\n            } // ------ e._lockedAngle = _lockedAngle\n\n\n            if (!this._bypassSpin) {\n              e.setSpinVariation((0, _Utils.randomBetween)(-this._currentSpinVariation, this._currentSpinVariation) + this._currentSpin);\n            } // weight\n\n\n            if (!this._bypassWeight) {\n              e.setWeight(this.getEmitterWeight(0));\n              e.setWeightVariation((0, _Utils.randomBetween)(-this._currentWeightVariation, this._currentWeightVariation));\n              e.setBaseWeight((this._currentWeight + e.getWeightVariation()) * parentEffect.getCurrentWeight());\n            } // -------------------\n\n\n            if (this._lockedAngle) {\n              if (!this._bypassWeight && !this._bypassSpeed && !parentEffect.isBypassWeight()) {\n                e.setSpeedVecX(Math.sin(e.getEntityDirection() / 180.0 * _Utils.M_PI));\n                e.setSpeedVecY(Math.cos(e.getEntityDirection() / 180.0 * _Utils.M_PI));\n                e.setAngle((0, _Utils.getDirection)(0, 0, e._speedVec.x, -e._speedVec.y));\n              } else {\n                if (parentEffect.getTraverseEdge()) {\n                  e.SetAngle(parentEffect.getAngle() + this._angleOffset);\n                } else {\n                  e.setAngle(e.getEntityDirection() + this._angle + this._angleOffset);\n                }\n              }\n            } else {\n              switch (this._angleType) {\n                case AngAlign:\n                  if (parentEffect.getTraverseEdge()) e.setAngle(parentEffect.getAngle() + this._angleOffset);else e.setAngle(e.getEntityDirection() + this._angleOffset);\n                  break;\n\n                case AngRandom:\n                  e.setAngle((0, _Utils.random)(this._angleOffset));\n                  break;\n\n                case AngSpecify:\n                  e.setAngle(this._angleOffset);\n                  break;\n              }\n            } // color settings\n\n\n            if (this._randomColor) {\n              var randomAge = (0, _Utils.random)(this._cR.getLastFrame());\n              e.setRed(this.randomizeR(e, randomAge));\n              e.setGreen(this.randomizeG(e, randomAge));\n              e.setBlue(this.randomizeB(e, randomAge));\n            } else {\n              e.setRed(this.getEmitterR(0));\n              e.setGreen(this.getEmitterG(0));\n              e.setBlue(this.getEmitterB(0));\n            }\n\n            e.setEntityAlpha(e.getEmitter().getEmitterAlpha(e.getAge(), e.getLifeTime()) * parentEffect.getCurrentAlpha()); // blend mode\n\n            e._blendMode = this._blendMode; // animation and framerate\n\n            e._animating = this._animate;\n            e._animateOnce = this._once;\n            e._framerate = this.getEmitterFramerate(0);\n            if (this._randomStartFrame) e._currentFrame = (0, _Utils.random)(e._avatar.getFramesCount());else e._currentFrame = this._currentFrame;\n\n            for (var i = 0; i < this._effects.length; i++) {\n              var newEffect = new _Effect2.default(this._effects[i], pm);\n              newEffect.setParent(e);\n              newEffect.setParentEmitter(this);\n              newEffect.setEffectLayer(e._effectLayer);\n            }\n\n            parentEffect.setParticlesCreated(true); // get the relative angle\n\n            if (!this._relative) {\n              var radians = e._angle / 180.0 * _Utils.M_PI;\n\n              e._matrix.set(Math.cos(radians), Math.sin(radians), -Math.sin(radians), Math.cos(radians));\n\n              e._matrix.transformSelf(this._parent.getMatrix());\n            }\n\n            e._relativeAngle = this._parent.getRelativeAngle() + e._angle;\n            e.updateEntityRadius();\n            e.updateBoundingBox(); // capture old values for tweening\n\n            e.capture();\n            if (pm.onParticleSpawnCB) pm.onParticleSpawnCB(e);\n          }\n        }\n\n        this._counter -= intCounter;\n      }\n    }\n  }, {\n    key: \"controlParticle\",\n    value: function controlParticle(e) {\n      var parentEffect = this._parentEffect;\n      var pm = parentEffect.getParticleManager(); // alpha change\n\n      if (this._alphaRepeat > 1) {\n        e._rptAgeA += _EffectsLibrary2.default.getCurrentUpdateTime() * this._alphaRepeat;\n        e._alpha = this.getEmitterAlpha(e._rptAgeA, e._lifeTime) * parentEffect.getCurrentAlpha();\n\n        if (e._rptAgeA > e._lifeTime && e._aCycles < this._alphaRepeat) {\n          e._rptAgeA -= e._lifeTime;\n          ++e._aCycles;\n        }\n      } else {\n        e._alpha = this.getEmitterAlpha(e._age, e._lifeTime) * parentEffect.getCurrentAlpha();\n      } // angle changes\n\n\n      if (this._lockedAngle && this._angleType == AngAlign) {\n        if (e._directionLocked) {\n          e._angle = parentEffect.getAngle() + this._angle + this._angleOffset;\n        } else {\n          if (!this._bypassWeight && !parentEffect.isBypassWeight() || e._direction) {\n            if (e._oldWX != e._wx && e._oldWY != e._wy) {\n              if (e._relative) e._angle = (0, _Utils.getDirection)(e._oldX, e._oldY, e._x, e._y);else e._angle = (0, _Utils.getDirection)(e._oldWX, e._oldWY, e._wx, e._wy);\n\n              if (Math.abs(e._oldAngle - e._angle) > 180) {\n                if (e._oldAngle > e._angle) e._oldAngle -= 360;else e._oldAngle += 360;\n              }\n            }\n          } else {\n            e._angle = e._direction + this._angle + this._angleOffset;\n          }\n        }\n      } else {\n        if (!this._bypassSpin) e._angle += this.getEmitterSpin(e._age, e._lifeTime) * e._spinVariation * parentEffect.getCurrentSpin() / _EffectsLibrary2.default.getCurrentUpdateTime();\n      } // direction changes and motion randomness\n\n\n      if (e._directionLocked) {\n        e._direction = 90;\n\n        switch (parentEffect.getClass()) {\n          case _Effect.TypeLine:\n            if (parentEffect._distanceSetByLife) {\n              var life = e._age / e._lifeTime;\n              e._x = life * parentEffect.getCurrentWidth() - parentEffect.getHandleX();\n            } else {\n              switch (parentEffect._endBehavior) {\n                case _Effect.EndKill:\n                  if (e._x > parentEffect.getCurrentWidth() - parentEffect.getHandleX() || e._x < 0 - parentEffect.getHandleX()) e._dead = 2;\n                  break;\n\n                case _Effect.EndLoopAround:\n                  if (e._x > parentEffect.getCurrentWidth() - parentEffect.getHandleX()) {\n                    e._x = -parentEffect.getHandleX();\n                    e.miniUpdate();\n                    e._oldX = e._x;\n                    e._oldWX = e._wx;\n                    e._oldWY = e._wy;\n                  } else if (e._x < 0 - parentEffect.getHandleX()) {\n                    e._x = parentEffect.getCurrentWidth() - parentEffect.getHandleX();\n                    e.miniUpdate();\n                    e._oldX = e._x;\n                    e._oldWX = e._wx;\n                    e._oldWY = e._wy;\n                  }\n\n                  break;\n              }\n            }\n\n        }\n      } else {\n        if (!this._bypassDirectionvariation) {\n          var dv = e._directionVariation * this.getEmitterDirectionVariationOt(e._age, e._lifeTime);\n          e._timeTracker += _EffectsLibrary2.default.getUpdateTime();\n\n          if (e._timeTracker > _EffectsLibrary2.default.motionVariationInterval) {\n            e._randomDirection += _EffectsLibrary2.default.maxDirectionVariation * (0, _Utils.randomBetween)(-dv, dv);\n            e._randomSpeed += _EffectsLibrary2.default.maxVelocityVariation * (0, _Utils.randomBetween)(-dv, dv);\n            e._timeTracker = 0;\n          }\n        }\n\n        e._direction = e._emissionAngle + this.getEmitterDirection(e._age, e._lifeTime) + e._randomDirection;\n      } // size changes\n\n\n      if (!this._bypassScaleX) {\n        e._scaleX = this.getEmitterScaleX(e._age, e._lifeTime) * e._gSizeX * e._width / this._image.getWidth();\n      }\n\n      if (this._uniform) {\n        if (!this._bypassScaleX) e._scaleY = e._scaleX;\n      } else {\n        if (!this._bypassScaleY) {\n          e._scaleY = this.getEmitterScaleY(e._age, e._lifeTime) * e._gSizeY * e._height / this._image.getHeight();\n        }\n      } // color changes\n\n\n      if (!this._bypassColor) {\n        if (!this._randomColor) {\n          if (this._colorRepeat > 1) {\n            e._rptAgeC += _EffectsLibrary2.default.getCurrentUpdateTime() * this._colorRepeat;\n            e._red = this.getEmitterR(e._rptAgeC, e._lifeTime);\n            e._green = this.getEmitterG(e._rptAgeC, e._lifeTime);\n            e._blue = this.getEmitterB(e._rptAgeC, e._lifeTime);\n\n            if (e._rptAgeC > e._lifeTime && e._cCycles < this._colorRepeat) {\n              e._rptAgeC -= e._lifeTime;\n              ++e._cCycles;\n            }\n          } else {\n            e._red = this.getEmitterR(e._age, e._lifeTime);\n            e._green = this.getEmitterG(e._age, e._lifeTime);\n            e._blue = this.getEmitterB(e._age, e._lifeTime);\n          }\n        }\n      } // animation\n\n\n      if (!this._bypassFramerate) e._framerate = this.getEmitterFramerate(e._age, e._lifeTime) * this._animationDirection; // speed changes\n\n      if (!this._bypassSpeed) {\n        e._speed = this.getEmitterVelocity(e._age, e._lifeTime) * e._baseSpeed * this.getEmitterGlobalVelocity(parentEffect.getCurrentEffectFrame());\n        e._speed += e._randomSpeed;\n      } else {\n        e._speed = e._randomSpeed;\n      } // stretch\n\n\n      if (!this._bypassStretch) {\n        if (!this._bypassWeight && !parentEffect.isBypassWeight()) {\n          if (e._speed !== 0) {\n            e._speedVec.x = e._speedVec.x / _EffectsLibrary2.default.getCurrentUpdateTime();\n            e._speedVec.y = e._speedVec.y / _EffectsLibrary2.default.getCurrentUpdateTime() - e._gravity;\n          } else {\n            e._speedVec.x = 0;\n            e._speedVec.y = -e._gravity;\n          }\n\n          if (this._uniform) e._scaleY = this.getEmitterScaleX(e._age, e._lifeTime) * e._gSizeX * (e._width + Math.abs(e._speed) * this.getEmitterStretch(e._age, e._lifeTime) * parentEffect.getCurrentStretch()) / this._image.getWidth();else e._scaleY = this.getEmitterScaleY(e._age, e._lifeTime) * e._gSizeY * (e._height + Math.abs(e._speed) * this.getEmitterStretch(e._age, e._lifeTime) * parentEffect.getCurrentStretch()) / this._image.getHeight();\n        } else {\n          if (this._uniform) e._scaleY = this.getEmitterScaleX(e._age, e._lifeTime) * e._gSizeX * (e._width + Math.abs(e._speed) * this.getEmitterStretch(e._age, e._lifeTime) * parentEffect.getCurrentStretch()) / this._image.getWidth();else e._scaleY = this.getEmitterScaleY(e._age, e._lifeTime) * e._gSizeY * (e._height + Math.abs(e._speed) * this.getEmitterStretch(e._age, e._lifeTime) * parentEffect.getCurrentStretch()) / this._image.getHeight();\n        }\n\n        if (e._scaleY < e._scaleX) e._scaleY = e._scaleX;\n      } // weight changes\n\n\n      if (!this._bypassWeight) e._weight = this.getEmitterWeight(e._age, e._lifeTime) * e._baseWeight;\n    }\n  }, {\n    key: \"randomizeR\",\n    value: function randomizeR(e, randomAge) {\n      return this._cR.getOt(randomAge, e.getLifeTime(), false);\n    }\n  }, {\n    key: \"randomizeG\",\n    value: function randomizeG(e, randomAge) {\n      return this._cG.getOt(randomAge, e.getLifeTime(), false);\n    }\n  }, {\n    key: \"randomizeB\",\n    value: function randomizeB(e, randomAge) {\n      return this._cB.getOt(randomAge, e.getLifeTime(), false);\n    }\n  }, {\n    key: \"drawCurrentFrame\",\n    value: function drawCurrentFrame(x\n    /*= 0*/\n    , y\n    /*= 0*/\n    , w\n    /*= 128.0*/\n    , h\n    /*= 128.0*/\n    ) {\n      if (this._image) {\n        /*\n        SetAlpha(1.0);\n        SetBlend(this._blendMode);\n        SetImageHandle(this._image.GetImage(), 0, 0);\n        SetColor(255, 255, 255);\n        SetScale(w / _image.GetWidth(), _image.GetHeight());\n        _image.Draw(x, y, _frame);\n        */\n      }\n    }\n  }, {\n    key: \"compileAll\",\n    value: function compileAll() {\n      // base\n      this._cLife.compile();\n\n      this._cLifeVariation.compile();\n\n      this._cAmount.compile();\n\n      this._cSizeX.compile();\n\n      this._cSizeY.compile();\n\n      this._cBaseSpeed.compile();\n\n      this._cBaseWeight.compile();\n\n      this._cBaseSpin.compile();\n\n      this._cEmissionAngle.compile();\n\n      this._cEmissionRange.compile();\n\n      this._cSplatter.compile();\n\n      this._cVelVariation.compile();\n\n      this._cWeightVariation.compile();\n\n      this._cAmountVariation.compile();\n\n      this._cSizeXVariation.compile();\n\n      this._cSizeYVariation.compile();\n\n      this._cSpinVariation.compile();\n\n      this._cDirectionVariation.compile(); // over lifetime\n\n\n      var longestLife = this.getLongestLife();\n\n      this._cAlpha.compileOT(longestLife);\n\n      this._cR.compileOT(longestLife);\n\n      this._cG.compileOT(longestLife);\n\n      this._cB.compileOT(longestLife);\n\n      this._cScaleX.compileOT(longestLife);\n\n      this._cScaleY.compileOT(longestLife);\n\n      this._cSpin.compileOT(longestLife);\n\n      this._cVelocity.compileOT(longestLife);\n\n      this._cWeight.compileOT(longestLife);\n\n      this._cDirection.compileOT(longestLife);\n\n      this._cDirectionVariationOT.compileOT(longestLife);\n\n      this._cFramerate.compileOT(longestLife);\n\n      this._cStretch.compileOT(longestLife); // global adjusters\n\n\n      this._cGlobalVelocity.compile();\n\n      for (var i = 0; i < this._effects.length; i++) {\n        this._effects[i].compileAll();\n      }\n\n      this.analyseEmitter();\n    }\n  }, {\n    key: \"compileQuick\",\n    value: function compileQuick() {\n      var longestLife = this.getLongestLife();\n\n      this._cAlpha.clear(1);\n\n      this._cAlpha.setCompiled(0, this.getEmitterAlpha(0, longestLife));\n\n      this._cR.clear(1);\n\n      this._cG.clear(1);\n\n      this._cB.clear(1);\n\n      this._cR.setCompiled(0, this.GetEmitterR(0, longestLife));\n\n      this._cG.setCompiled(0, this.GetEmitterG(0, longestLife));\n\n      this._cB.setCompiled(0, this.GetEmitterB(0, longestLife));\n\n      this._cScaleX.clear(1);\n\n      this._cScaleY.clear(1);\n\n      this._cScaleX.SetCompiled(0, this.GetEmitterScaleX(0, longestLife));\n\n      this._cScaleY.SetCompiled(0, this.GetEmitterScaleY(0, longestLife));\n\n      this._cVelocity.clear(1);\n\n      this._cVelocity.SetCompiled(0, this.GetEmitterVelocity(0, longestLife));\n\n      this._cWeight.clear(1);\n\n      this._cWeight.SetCompiled(0, this.GetEmitterWeight(0, longestLife));\n\n      this._cDirection.clear(1);\n\n      this._cDirection.SetCompiled(0, this.GetEmitterDirection(0, longestLife));\n\n      this._cDirectionVariationOT.clear(1);\n\n      this._cDirectionVariationOT.SetCompiled(0, this.GetEmitterDirectionVariationOT(0, longestLife));\n\n      this._cFramerate.clear(1);\n\n      this._cFramerate.SetCompiled(0, this.GetEmitterFramerate(0, longestLife));\n\n      this._cStretch.clear(1);\n\n      this._cStretch.SetCompiled(0, this.GetEmitterStretch(0, longestLife));\n\n      this._cSplatter.clear(1);\n\n      this._cSplatter.SetCompiled(0, this.GetEmitterSplatter(0));\n    }\n  }, {\n    key: \"analyseEmitter\",\n    value: function analyseEmitter() {\n      this.resetBypassers();\n      if (!this._cLifeVariation.getLastFrame() && !this.getEmitterLifeVariation(0)) this._bypassLifeVariation = true;\n      if (!this.getEmitterStretch(0, 1.0)) this._bypassStretch = true;\n      if (!this._cFramerate.getLastFrame() && !this.getEmitterSplatter(0)) this._bypassFramerate = true;\n      if (!this._cSplatter.getLastFrame() && !this._cSplatter.get(0)) this._bypassSplatter = true;\n      if (!this._cBaseWeight.getLastFrame() && !this._cWeightVariation.getLastFrame() && !this.getEmitterBaseWeight(0) && !this.getEmitterWeightVariation(0)) this._bypassWeight = true;\n      if (!this._cWeight.getLastFrame() && !this._cWeight.get(0)) this._bypassWeight = true;\n      if (!this._cBaseSpeed.getLastFrame() && !this._cVelVariation.getLastFrame() && !this.getEmitterBaseSpeed(0) && !this.getEmitterVelVariation(0)) this._bypassSpeed = true;\n      if (!this._cBaseSpin.getLastFrame() && !this._cSpinVariation.getLastFrame() && !this.getEmitterBaseSpin(0) && !this.getEmitterSpinVariation(0)) this._bypassSpin = true;\n      if (!this._cDirectionVariation.getLastFrame() && !this.getEmitterDirectionVariation(0)) this._bypassDirectionvariation = true;\n\n      if (this._cR.getAttributesCount() <= 1) {\n        this._bRed = this.getEmitterR(0, 1.0) !== 0;\n        this._bGreen = this.getEmitterG(0, 1.0) !== 0;\n        this._bBlue = this.getEmitterB(0, 1.0) !== 0;\n        this._bypassColor = true;\n      }\n\n      if (this._cScaleX.getAttributesCount() <= 1) this._bypassScaleX = true;\n      if (this._cScaleY.getAttributesCount() <= 1) this._bypassScaleY = true;\n    }\n  }, {\n    key: \"resetBypassers\",\n    value: function resetBypassers() {\n      this._bypassWeight = false;\n      this._bypassSpeed = false;\n      this._bypassSpin = false;\n      this._bypassDirectionvariation = false;\n      this._bypassColor = false;\n      this._bRed = false;\n      this._bGreen = false;\n      this._bBlue = false;\n      this._bypassScaleX = false;\n      this._bypassScaleY = false;\n      this._bypassLifeVariation = false;\n      this._bypassFramerate = false;\n      this._bypassStretch = false;\n      this._bypassSplatter = false;\n    }\n  }, {\n    key: \"getLongestLife\",\n    value: function getLongestLife() {\n      var longestLife = (this._cLifeVariation.getMaxValue() + this._cLife.getMaxValue()) * this._parentEffect.getLifeMaxValue();\n\n      return longestLife; // No idea what units we're supposed to be using here\n      // return this._parentEffect.GetLifeMaxValue();\n    }\n  }, {\n    key: \"getEmitterLife\",\n    value: function getEmitterLife(frame) {\n      return this._cLife.get(frame);\n    }\n  }, {\n    key: \"getEmitterLifeVariation\",\n    value: function getEmitterLifeVariation(frame) {\n      return this._cLifeVariation.get(frame);\n    }\n  }, {\n    key: \"getEmitterAmount\",\n    value: function getEmitterAmount(frame) {\n      return this._cAmount.get(frame);\n    }\n  }, {\n    key: \"getEmitterSizeX\",\n    value: function getEmitterSizeX(frame) {\n      return this._cSizeX.get(frame);\n    }\n  }, {\n    key: \"getEmitterSizeY\",\n    value: function getEmitterSizeY(frame) {\n      return this._cSizeY.get(frame);\n    }\n  }, {\n    key: \"getEmitterBaseSpeed\",\n    value: function getEmitterBaseSpeed(frame) {\n      return this._cBaseSpeed.get(frame);\n    }\n  }, {\n    key: \"getEmitterBaseWeight\",\n    value: function getEmitterBaseWeight(frame) {\n      return this._cBaseWeight.get(frame);\n    }\n  }, {\n    key: \"getEmitterBaseSpin\",\n    value: function getEmitterBaseSpin(frame) {\n      return this._cBaseSpin.get(frame);\n    }\n  }, {\n    key: \"getEmitterEmissionAngle\",\n    value: function getEmitterEmissionAngle(frame) {\n      return this._cEmissionAngle.get(frame);\n    }\n  }, {\n    key: \"getEmitterEmissionRange\",\n    value: function getEmitterEmissionRange(frame) {\n      return this._cEmissionRange.get(frame);\n    }\n  }, {\n    key: \"getEmitterSplatter\",\n    value: function getEmitterSplatter(frame) {\n      return this._cSplatter.get(frame);\n    }\n  }, {\n    key: \"getEmitterVelVariation\",\n    value: function getEmitterVelVariation(frame) {\n      return this._cVelVariation.get(frame);\n    }\n  }, {\n    key: \"getEmitterWeightVariation\",\n    value: function getEmitterWeightVariation(frame) {\n      return this._cWeightVariation.get(frame);\n    }\n  }, {\n    key: \"getEmitterAmountVariation\",\n    value: function getEmitterAmountVariation(frame) {\n      return this._cAmountVariation.get(frame);\n    }\n  }, {\n    key: \"getEmitterSizeXVariation\",\n    value: function getEmitterSizeXVariation(frame) {\n      return this._cSizeXVariation.get(frame);\n    }\n  }, {\n    key: \"getEmitterSizeYVariation\",\n    value: function getEmitterSizeYVariation(frame) {\n      return this._cSizeYVariation.get(frame);\n    }\n  }, {\n    key: \"getEmitterSpinVariation\",\n    value: function getEmitterSpinVariation(frame) {\n      return this._cSpinVariation.get(frame);\n    }\n  }, {\n    key: \"getEmitterDirectionVariation\",\n    value: function getEmitterDirectionVariation(frame) {\n      return this._cDirectionVariation.get(frame);\n    }\n  }, {\n    key: \"getEmitterAlpha\",\n    value: function getEmitterAlpha(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cAlpha.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterR\",\n    value: function getEmitterR(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cR.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterG\",\n    value: function getEmitterG(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cG.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterB\",\n    value: function getEmitterB(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cB.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterScaleX\",\n    value: function getEmitterScaleX(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cScaleX.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterScaleY\",\n    value: function getEmitterScaleY(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cScaleY.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterSpin\",\n    value: function getEmitterSpin(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cSpin.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterVelocity\",\n    value: function getEmitterVelocity(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cVelocity.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterWeight\",\n    value: function getEmitterWeight(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cWeight.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterDirection\",\n    value: function getEmitterDirection(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cDirection.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterDirectionVariationOt\",\n    value: function getEmitterDirectionVariationOt(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cDirectionVariationOT.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterFramerate\",\n    value: function getEmitterFramerate(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cFramerate.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterStretch\",\n    value: function getEmitterStretch(age) {\n      var lifetime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._cStretch.getOt(age, lifetime);\n    }\n  }, {\n    key: \"getEmitterGlobalVelocity\",\n    value: function getEmitterGlobalVelocity(frame) {\n      return this._cGlobalVelocity.get(frame);\n    }\n  }, {\n    key: \"getEffects\",\n    value: function getEffects() {\n      return this._effects;\n    }\n  }, {\n    key: \"isDying\",\n    value: function isDying() {\n      return this._dying;\n    }\n  }, {\n    key: \"setPath\",\n    value: function setPath(path) {\n      this._path = path;\n    }\n  }, {\n    key: \"getImages\",\n    value: function getImages(images) {\n      if (this._image) images[this._image._index] = this._image;\n\n      for (var i = 0; i < this._effects.length; i++) {\n        this._effects[i].getImages(images);\n      }\n    }\n  }]);\n\n  return Emitter;\n}(_Entity3.default);\n\nexports.default = Emitter;\n\n//# sourceURL=webpack:///./src/Emitter.js?");

/***/ }),

/***/ "./src/EmitterArray.js":
/*!*****************************!*\
  !*** ./src/EmitterArray.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EffectsLibrary = __webpack_require__(/*! ./EffectsLibrary */ \"./src/EffectsLibrary.js\");\n\nvar _EffectsLibrary2 = _interopRequireDefault(_EffectsLibrary);\n\nvar _AttributeNode = __webpack_require__(/*! ./AttributeNode */ \"./src/AttributeNode.js\");\n\nvar _AttributeNode2 = _interopRequireDefault(_AttributeNode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar EmitterArray =\n/*#__PURE__*/\nfunction () {\n  function EmitterArray(min, max) {\n    _classCallCheck(this, EmitterArray);\n\n    this._life = 0;\n    this._compiled = false;\n    this._min = min;\n    this._max = max;\n    this._changes = [];\n    this._attributes = [];\n  }\n\n  _createClass(EmitterArray, [{\n    key: \"getLastFrame\",\n    value: function getLastFrame() {\n      return this._changes.length - 1;\n    }\n  }, {\n    key: \"getCompiled\",\n    value: function getCompiled(frame) {\n      frame = Math.round(frame);\n      var lastFrame = this.getLastFrame();\n\n      if (frame <= lastFrame) {\n        return this._changes[frame];\n      }\n\n      return this._changes[lastFrame];\n    }\n  }, {\n    key: \"setCompiled\",\n    value: function setCompiled(frame, value) {\n      this._changes[frame] = value;\n    }\n  }, {\n    key: \"getLife\",\n    value: function getLife() {\n      return this._life;\n    }\n  }, {\n    key: \"setLife\",\n    value: function setLife(life) {\n      this._life = life;\n    }\n  }, {\n    key: \"getLastAtrribute\",\n    value: function getLastAtrribute() {\n      return this._attributes[this._attributes.length - 1];\n    }\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      if (this._attributes.length > 0) {\n        var lastec = this.getLastAtrribute();\n\n        var lookupFrequency = _EffectsLibrary2.default.getLookupFrequency();\n\n        var frame = Math.ceil(lastec.frame / lookupFrequency);\n        this._changes = new Array(frame + 1);\n        frame = 0;\n        var age = 0;\n\n        while (age < lastec.frame) {\n          this.setCompiled(frame, this.interpolate(age));\n          ++frame;\n          age = frame * lookupFrequency;\n        }\n\n        this.setCompiled(frame, lastec.value);\n      } else {\n        this._changes = [0];\n      }\n\n      this._compiled = true;\n    }\n  }, {\n    key: \"compileOT\",\n    value: function compileOT() {\n      var longestLife = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLastAtrribute().frame;\n\n      if (this._attributes.length > 0) {\n        //   longestLife = GetDefaultArg(longestLife, this.GetLastAtrribute().frame);\n        var lastec = this.getLastAtrribute();\n\n        var lookupFrequency = _EffectsLibrary2.default.getLookupFrequencyOverTime(); // TODO\n\n\n        var frame = Math.ceil(longestLife / lookupFrequency);\n        this._changes = new Array(frame + 1);\n        frame = 0;\n        var age = 0;\n\n        while (age < longestLife) {\n          this.setCompiled(frame, this.interpolateOT(age, longestLife));\n          ++frame;\n          age = frame * lookupFrequency;\n        }\n\n        this.setLife(longestLife);\n        this.setCompiled(frame, lastec.value);\n      } else {\n        this._changes = [0];\n      }\n\n      this._compiled = true;\n    }\n  }, {\n    key: \"add\",\n    value: function add(frame, value) {\n      this._compiled = false;\n      var e = new _AttributeNode2.default();\n      e.frame = frame;\n      e.value = value;\n\n      this._attributes.push(e);\n\n      return e;\n    }\n  }, {\n    key: \"get\",\n    value: function get(frame) {\n      var bezier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this._compiled) return this.getCompiled(frame);else return this.interpolate(frame, bezier);\n    }\n  }, {\n    key: \"getBezierValue\",\n    value: function getBezierValue(lastec, a, t, yMin, yMax) {\n      if (a.isCurve) {\n        var p0x = lastec.frame;\n        var p0y = lastec.value;\n\n        if (lastec.isCurve) {\n          var p1x = lastec.c1x;\n          var p1y = lastec.c1y;\n          var p2x = a.c0x;\n          var p2y = a.c0y;\n          var p3x = a.frame;\n          var p3y = a.value;\n          return this.getCubicBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t, yMin, yMax).y;\n        } else {\n          var _p1x = a.c0x;\n          var _p1y = a.c0y;\n          var _p2x = a.frame;\n          var _p2y = a.value;\n          return this.getQuadBezier(p0x, p0y, _p1x, _p1y, _p2x, _p2y, t, yMin, yMax).y;\n        }\n      } else if (lastec.isCurve) {\n        var _p0x = lastec.frame;\n        var _p0y = lastec.value;\n        var _p1x2 = lastec.c1x;\n        var _p1y2 = lastec.c1y;\n        var _p2x2 = a.frame;\n        var _p2y2 = a.value;\n        return this.getQuadBezier(_p0x, _p0y, _p1x2, _p1y2, _p2x2, _p2y2, t, yMin, yMax).y;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"getQuadBezier\",\n    value: function getQuadBezier(p0x, p0y, p1x, p1y, p2x, p2y, t, yMin, yMax) {\n      var clamp = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : true;\n      var x = (1 - t) * (1 - t) * p0x + 2 * t * (1 - t) * p1x + t * t * p2x;\n      var y = (1 - t) * (1 - t) * p0y + 2 * t * (1 - t) * p1y + t * t * p2y;\n      if (x < p0x) x = p0x;\n      if (x > p2x) x = p2x;\n\n      if (clamp) {\n        if (y < yMin) y = yMin;\n        if (y > yMax) y = yMax;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"getCubicBezier\",\n    value: function getCubicBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t, yMin, yMax) {\n      var clamp = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : true;\n      var x = (1 - t) * (1 - t) * (1 - t) * p0x + 3 * t * (1 - t) * (1 - t) * p1x + 3 * t * t * (1 - t) * p2x + t * t * t * p3x;\n      var y = (1 - t) * (1 - t) * (1 - t) * p0y + 3 * t * (1 - t) * (1 - t) * p1y + 3 * t * t * (1 - t) * p2y + t * t * t * p3y;\n      if (x < p0x) x = p0x;\n      if (x > p3x) x = p3x;\n\n      if (clamp) {\n        if (y < yMin) y = yMin;\n        if (y > yMax) y = yMax;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(frame) {\n      return this.interpolateOT(frame, 1.0);\n    }\n  }, {\n    key: \"interpolateOT\",\n    value: function interpolateOT(age, lifetime) {\n      var bezier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var lasty = 0;\n      var lastf = 0;\n      var lastec = null;\n\n      for (var i = 0; i < this._attributes.length; i++) {\n        var it = this._attributes[i];\n        var frame = it.frame * lifetime;\n\n        if (age < frame) {\n          var p = (age - lastf) / (frame - lastf);\n\n          if (bezier) {\n            var bezierValue = this.getBezierValue(lastec, it, p, this._min, this._max);\n\n            if (bezierValue !== 0) {\n              return bezierValue;\n            }\n          }\n\n          return lasty - p * (lasty - it.value);\n        }\n\n        lasty = it.value;\n        lastf = frame;\n        if (bezier) lastec = it;\n      }\n\n      return lasty;\n    }\n  }, {\n    key: \"getOt\",\n    value: function getOt(age, lifetime) {\n      var frame = 0;\n\n      if (lifetime > 0) {\n        frame = age / lifetime * this._life / _EffectsLibrary2.default.getLookupFrequencyOverTime(); // TODO\n      }\n\n      return this.get(frame);\n    }\n  }, {\n    key: \"getAttributesCount\",\n    value: function getAttributesCount() {\n      return this._attributes.length;\n    }\n  }, {\n    key: \"getMaxValue\",\n    value: function getMaxValue() {\n      var max = 0;\n\n      for (var i = 0; i < this._attributes.length; i++) {\n        var val = this._attributes[i].value;\n        if (val > max) max = val;\n      }\n\n      return max;\n    }\n  }]);\n\n  return EmitterArray;\n}();\n\nexports.default = EmitterArray;\n\n//# sourceURL=webpack:///./src/EmitterArray.js?");

/***/ }),

/***/ "./src/Entity.js":
/*!***********************!*\
  !*** ./src/Entity.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Blend = undefined;\n\nvar _Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nvar _Matrix = __webpack_require__(/*! ./Matrix2 */ \"./src/Matrix2.js\");\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nvar _Vector = __webpack_require__(/*! ./Vector2 */ \"./src/Vector2.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _EffectsLibrary = __webpack_require__(/*! ./EffectsLibrary */ \"./src/EffectsLibrary.js\");\n\nvar _EffectsLibrary2 = _interopRequireDefault(_EffectsLibrary);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Blend = exports.Blend = {\n  BMAlphaBlend: 3,\n  BMLightBlend: 4 // check loading values are one of these\n\n};\nvar g_defaultEntity = {\n  _x: 0,\n  _y: 0,\n  _name: \"\",\n  _oldX: 0,\n  _oldY: 0,\n  _wx: 0,\n  _wy: 0,\n  _oldWX: 0,\n  _oldWY: 0,\n  _z: 1.0,\n  _oldZ: 1.0,\n  _relative: true,\n  _r: 0,\n  _g: 0,\n  _b: 0,\n  _red: 255,\n  _green: 255,\n  _blue: 255,\n  _oldRed: 255,\n  _oldGreen: 255,\n  _oldBlue: 255,\n  _width: 0,\n  _height: 0,\n  _weight: 0,\n  _gravity: 0,\n  _baseWeight: 0,\n  _oldWeight: 0,\n  _scaleX: 1.0,\n  _scaleY: 1.0,\n  _sizeX: 1.0,\n  _sizeY: 1.0,\n  _oldScaleX: 1.0,\n  _oldScaleY: 1.0,\n  _speed: 0,\n  _baseSpeed: 0,\n  _oldSpeed: 0,\n  _updateSpeed: true,\n  _direction: 0,\n  _directionLocked: false,\n  _angle: 0,\n  _oldAngle: 0,\n  _relativeAngle: 0,\n  _oldRelativeAngle: 0,\n  _avatar: null,\n  _frameOffset: 0,\n  _framerate: 1.0,\n  _currentFrame: 0,\n  _oldCurrentFrame: 0,\n  _animating: false,\n  _animateOnce: false,\n  _animAction: 0,\n  _handleX: 0,\n  _handleY: 0,\n  _autoCenter: true,\n  _okToRender: true,\n  _dob: 0,\n  _age: 0,\n  _rptAgeA: 0,\n  _rptAgeC: 0,\n  _aCycles: 0,\n  _cCycles: 0,\n  _oldAge: 0,\n  _dead: 0,\n  _destroyed: false,\n  _lifeTime: 0,\n  _timediff: 0,\n  _AABB_Calculate: true,\n  _collisionXMin: 0,\n  _collisionYMin: 0,\n  _collisionXMax: 0,\n  _collisionYMax: 0,\n  _AABB_XMin: 0,\n  _AABB_YMin: 0,\n  _AABB_XMax: 0,\n  _AABB_YMax: 0,\n  _AABB_MaxWidth: 0,\n  _AABB_MaxHeight: 0,\n  _AABB_MinWidth: 0,\n  _AABB_MinHeight: 0,\n  _radiusCalculate: true,\n  _imageRadius: 0,\n  _entityRadius: 0,\n  _imageDiameter: 0,\n  _parent: null,\n  _rootParent: null,\n  _childrenOwner: true,\n  _blendMode: Blend.BMAlphaBlend,\n  _alpha: 1.0,\n  _oldAlpha: 0,\n  _runChildren: false,\n  _pixelsPerSecond: 0\n};\n\nvar Entity =\n/*#__PURE__*/\nfunction () {\n  function Entity(other) {\n    _classCallCheck(this, Entity);\n\n    if (other) {\n      for (var key in g_defaultEntity) {\n        this[key] = other[key];\n      }\n    } else {\n      for (var _key in g_defaultEntity) {\n        this[_key] = g_defaultEntity[_key];\n      }\n    }\n\n    this._matrix = new _Matrix2.default();\n    this._speedVec = new _Vector2.default();\n    this._children = [];\n  }\n\n  _createClass(Entity, [{\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      return this._destroyed;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }, {\n    key: \"setName\",\n    value: function setName(name) {\n      this._name = name;\n    }\n  }, {\n    key: \"setX\",\n    value: function setX(x) {\n      this._x = x;\n    }\n  }, {\n    key: \"setY\",\n    value: function setY(y) {\n      this._y = y;\n    }\n  }, {\n    key: \"setZ\",\n    value: function setZ(z) {\n      this._z = z;\n    }\n  }, {\n    key: \"getX\",\n    value: function getX() {\n      return this._x;\n    }\n  }, {\n    key: \"getY\",\n    value: function getY() {\n      return this._y;\n    }\n  }, {\n    key: \"getZ\",\n    value: function getZ() {\n      return this._z;\n    }\n  }, {\n    key: \"capture\",\n    value: function capture() {\n      this._oldZ = this._z;\n      this._oldWX = this._wx;\n      this._oldWY = this._wy;\n      this._oldX = this._x;\n      this._oldY = this._y;\n      this._oldAngle = this._angle;\n      this._oldRelativeAngle = this._relativeAngle;\n      this._oldScaleX = this._scaleX;\n      this._oldScaleY = this._scaleY;\n      this._oldCurrentFrame = this._currentFrame;\n    }\n  }, {\n    key: \"captureAll\",\n    value: function captureAll() {\n      this.capture();\n\n      for (var i = 0; i < this._children.length; i++) {\n        this._children[i].capture();\n      }\n    }\n  }, {\n    key: \"setOKtoRender\",\n    value: function setOKtoRender(ok) {\n      this._okToRender = ok;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._parent = null;\n      this._avatar = null;\n      this._rootParent = null;\n      this.clearChildren();\n      this._destroyed = true;\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(e) {\n      (0, _Utils.removeFromList)(this._children, e);\n      e._parent = null;\n    }\n  }, {\n    key: \"clearChildren\",\n    value: function clearChildren() {\n      if (this._children) {\n        for (var i = 0; i < this._children.length; i++) {\n          this._children[i].destroy();\n        }\n      }\n\n      this._children = [];\n    }\n  }, {\n    key: \"killChildren\",\n    value: function killChildren() {\n      for (var i = 0; i < this._children.length; i++) {\n        this._children[i].killChildren();\n\n        this._children[i]._dead = true;\n      }\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this._children;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var currentUpdateTime = _EffectsLibrary2.default.getCurrentUpdateTime(); // Update speed in pixels per second\n\n\n      if (this._updateSpeed && this._speed) {\n        this._pixelsPerSecond = this._speed / currentUpdateTime;\n        this._speedVec.x = Math.sin(this._direction / 180.0 * _Utils.M_PI) * this._pixelsPerSecond;\n        this._speedVec.y = Math.cos(this._direction / 180.0 * _Utils.M_PI) * this._pixelsPerSecond;\n        this._x += this._speedVec.x * this._z;\n        this._y -= this._speedVec.y * this._z;\n      } // update the gravity\n\n\n      if (this._weight !== 0) {\n        this._gravity += this._weight / currentUpdateTime;\n        this._y += this._gravity / currentUpdateTime * this._z;\n      } // set the matrix if it is relative to the parent\n\n\n      if (this._relative) {\n        var radians = this._angle / 180 * _Utils.M_PI;\n\n        this._matrix.set(Math.cos(radians), Math.sin(radians), -Math.sin(radians), Math.cos(radians));\n      } // calculate where the entity is in the world\n\n\n      if (this._parent && this._relative) {\n        this._z = this._parent._z;\n\n        this._matrix.transformSelf(this._parent._matrix);\n\n        var rotVec = this._parent._matrix.transformVector(this._x, this._y);\n\n        this._wx = this._parent._wx + rotVec.x * this._z;\n        this._wy = this._parent._wy + rotVec.y * this._z;\n        this._relativeAngle = this._parent._relativeAngle + this._angle;\n      } else {\n        // If parent setz(parent.z)\n        this._wx = this._x;\n        this._wy = this._y;\n      }\n\n      if (!this._parent) this._relativeAngle = this._angle; // update animation frame\n\n      if (this._avatar && this._animating) {\n        this._currentFrame += this._framerate / currentUpdateTime;\n\n        if (this._animateOnce) {\n          if (this._currentFrame > this._avatar.getFramesCount() - 1) {\n            this._currentFrame = this._avatar.getFramesCount() - 1;\n          } else if (this._currentFrame <= 0) {\n            this._currentFrame = 0;\n          }\n        }\n      } // update the Axis Aligned Bounding Box\n\n\n      if (this._AABB_Calculate) this.updateBoundingBox(); // update the radius of influence\n\n      if (this._radiusCalculate) this.updateEntityRadius(); // update the children\n\n      this.updateChildren();\n      return true;\n    }\n  }, {\n    key: \"updateChildren\",\n    value: function updateChildren() {\n      for (var i = 0; i < this._children.length; i++) {\n        if (!this._children[i].update()) {\n          this._children.splice(i, 1);\n\n          i--;\n        }\n      }\n    }\n  }, {\n    key: \"miniUpdate\",\n    value: function miniUpdate() {\n      var radians = this._angle / 180.0 * _Utils.M_PI;\n\n      if (isNaN(this._angle)) {\n        console.log(\"MiniUpdate NaN\");\n      }\n\n      this._matrix.set(Math.cos(radians), Math.sin(radians), -Math.sin(radians), Math.cos(radians));\n\n      if (this._parent && this._relative) {\n        this._z = this._parent._z;\n\n        this._matrix.transformSelf(this._parent._matrix);\n\n        var rotVec = this._parent._matrix.transformVector(this._x, this._y);\n\n        this._wx = this._parent._wx + rotVec.x * this._z;\n        this._wy = this._parent._wy + rotVec.y * this._z;\n      } else {\n        if (this._parent) this._z = this._parent._z;\n        this._wx = this._x;\n        this._wy = this._y;\n      }\n    }\n  }, {\n    key: \"getChildCount\",\n    value: function getChildCount() {\n      return this._children.length;\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox() {\n      this._collisionXMin = this._AABB_MinWidth * this._scaleX * this._z;\n      this._collisionYMin = this._AABB_MinHeight * this._scaleY * this._z;\n      this._collisionXMax = this._AABB_MaxWidth * this._scaleX * this._z;\n      this._collisionYMax = this._AABB_MaxHeight * this._scaleY * this._z;\n      this._AABB_XMin = this._collisionXMin;\n      this._AABB_YMin = this._collisionYMin;\n      this._AABB_XMax = this._collisionXMax;\n      this._AABB_YMax = this._collisionYMax;\n      if (this._children.length === 0) this.updateParentBoundingBox();\n    }\n  }, {\n    key: \"updateEntityRadius\",\n    value: function updateEntityRadius() {\n      if (this._autoCenter) {\n        if (this._avatar) {\n          var aMaxRadius = this._avatar.getMaxRadius();\n\n          var aWidth = this._avatar.getWidth();\n\n          var aHeight = this._avatar.getHeight();\n\n          if (aMaxRadius !== 0) this._imageRadius = Math.max(aMaxRadius * this._scaleX * this._z, aMaxRadius * this._scaleY * this._z);else this._imageRadius = (0, _Utils.getDistance2D)(aWidth / 2.0 * this._scaleX * this._z, aHeight / 2.0 * this._scaleY * this._z, aWidth * this._scaleX * this._z, aHeight * this._scaleY * this._z);\n        } else {\n          this._imageRadius = 0;\n        }\n      } else {\n        var _aMaxRadius = this._avatar.getMaxRadius();\n\n        var _aWidth = this._avatar.getWidth();\n\n        var _aHeight = this._avatar.getHeight();\n\n        if (_aMaxRadius !== 0) this._imageRadius = (0, _Utils.getDistance2D)(this._handleX * this._scaleX * this._z, this._handleY * this._scaleY * this._z, _aWidth / 2.0 * this._scaleX * this._z, _aHeight / 2.0 * this._scaleY * this._z) + Math.max(_aMaxRadius * this._scaleX * this._z, _aMaxRadius * this._scaleY * this._z);else this._imageRadius = (0, _Utils.getDistance2D)(this._handleX * this._scaleX * this._z, this._handleY * this._scaleY * this._z, _aWidth * this._scaleX * this._z, _aHeight * this._scaleY * this._z);\n      }\n\n      this._entityRadius = this._imageRadius;\n      this._imageDiameter = this._imageRadius * 2.0;\n      if (this._rootParent) this.updateRootParentEntityRadius();\n    }\n  }, {\n    key: \"updateParentEntityRadius\",\n    value: function updateParentEntityRadius() {\n      if (this._parent) {\n        if (this._children.length > 0) this._parent._entityRadius += Math.max(0.0, (0, _Utils.getDistance2D)(this._wx, this._wy, this._parent._wx, this._parent._wy) + this._entityRadius - this._parent._entityRadius);else this._parent._entityRadius += Math.max(0.0, (0, _Utils.getDistance2D)(this._wx, this._wy, this._parent._wx, this._parent._wy) + this._imageRadius - this._parent._entityRadius); // DebugLog name + \" - Radius: \" + entity_Radius + \" | Distance to Parent: \" + getdistance(wx, wy, parent.wx, parent.wy)\n\n        this._parent.updateParentEntityRadius();\n      }\n    }\n  }, {\n    key: \"updateRootParentEntityRadius\",\n    value: function updateRootParentEntityRadius() {\n      if (this._rootParent) {\n        if (this._alpha !== 0) this._rootParent._entityRadius += Math.max(0.0, (0, _Utils.getDistance2D)(this._wx, this._wy, this._rootParent._wx, this._rootParent._wy) + this._imageRadius - this._rootParent._entityRadius); // DebugLog name + \" - Radius: \" + entity_Radius + \" | Distance to Parent: \" + getdistance(wx, wy, rootparent.wx, rootparent.wy)\n      }\n    }\n  }, {\n    key: \"updateParentBoundingBox\",\n    value: function updateParentBoundingBox() {\n      if (this._parent) {\n        var parent = this._parent;\n        parent._AABB_XMax += Math.max(0.0, this._wx - parent._wx + this._AABB_XMax - parent._AABB_XMax);\n        parent._AABB_YMax += Math.max(0.0, this._wy - parent._wx + this._AABB_YMax - parent._AABB_YMax);\n        parent._AABB_XMin += Math.max(0.0, this._wx - parent._wx + this._AABB_XMin - parent._AABB_XMin);\n        parent._AABB_YMin += Math.max(0.0, this._wy - parent._wy + this._AABB_YMin - parent._AABB_YMin);\n      }\n    }\n  }, {\n    key: \"assignRootParent\",\n    value: function assignRootParent(e) {\n      if (this._parent) this._parent.assignRootParent(e);else e._rootParent = this;\n    }\n  }, {\n    key: \"setHandleX\",\n    value: function setHandleX(x) {\n      this._handleX = x;\n    }\n  }, {\n    key: \"setHandleY\",\n    value: function setHandleY(y) {\n      this._handleY = y;\n    }\n  }, {\n    key: \"setParent\",\n    value: function setParent(e) {\n      e.addChild(this);\n    }\n  }, {\n    key: \"setRelative\",\n    value: function setRelative(value) {\n      this._relative = value;\n    }\n  }, {\n    key: \"setEntityScale\",\n    value: function setEntityScale(sx, sy) {\n      this._scaleX = sx;\n      this._scaleY = sy;\n    }\n  }, {\n    key: \"setSpeed\",\n    value: function setSpeed(speed) {\n      this._speed = speed;\n    }\n  }, {\n    key: \"getSpeed\",\n    value: function getSpeed() {\n      return this._speed;\n    }\n  }, {\n    key: \"setBlendMode\",\n    value: function setBlendMode(mode) {\n      this._blendMode = mode;\n    }\n  }, {\n    key: \"getCurrentFrame\",\n    value: function getCurrentFrame() {\n      return this._currentFrame;\n    }\n  }, {\n    key: \"setCurrentFrame\",\n    value: function setCurrentFrame(frame) {\n      this._currentFrame = frame;\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(e) {\n      this._children.push(e);\n\n      e._parent = this;\n      e._radiusCalculate = this._radiusCalculate;\n      e.assignRootParent(e);\n    }\n  }, {\n    key: \"getMatrix\",\n    value: function getMatrix() {\n      return this._matrix;\n    }\n  }, {\n    key: \"getWX\",\n    value: function getWX() {\n      return this._wx;\n    }\n  }, {\n    key: \"getWY\",\n    value: function getWY() {\n      return this._wy;\n    }\n  }, {\n    key: \"getRelativeAngle\",\n    value: function getRelativeAngle() {\n      return this._relativeAngle;\n    }\n  }, {\n    key: \"setDoB\",\n    value: function setDoB(dob) {\n      this._dob = dob;\n    }\n  }, {\n    key: \"getOldCurrentFrame\",\n    value: function getOldCurrentFrame() {\n      return this._oldCurrentFrame;\n    }\n  }, {\n    key: \"setAvatar\",\n    value: function setAvatar(avatar) {\n      this._avatar = avatar;\n      this._AABB_MaxWidth = this._avatar.getWidth() * 0.5;\n      this._AABB_MaxHeight = this._avatar.getHeight() * 0.5;\n      this._AABB_MinWidth = this._avatar.getWidth() * -0.5;\n      this._AABB_MinHeight = this._avatar.getHeight() * -0.5;\n    }\n  }, {\n    key: \"setAutocenter\",\n    value: function setAutocenter(value) {\n      this._autoCenter = value;\n    }\n  }, {\n    key: \"getLifeTime\",\n    value: function getLifeTime() {\n      return this._lifeTime;\n    }\n  }, {\n    key: \"setLifeTime\",\n    value: function setLifeTime(lifeTime) {\n      this._lifeTime = lifeTime;\n    }\n  }, {\n    key: \"setSpeedVecX\",\n    value: function setSpeedVecX(x) {\n      this._speedVec.x = x;\n    }\n  }, {\n    key: \"setSpeedVecY\",\n    value: function setSpeedVecY(y) {\n      this._speedVec.y = y;\n    }\n  }, {\n    key: \"setBaseSpeed\",\n    value: function setBaseSpeed(speed) {\n      this._baseSpeed = speed;\n    }\n  }, {\n    key: \"getBaseSpeed\",\n    value: function getBaseSpeed() {\n      return this._baseSpeed;\n    }\n  }, {\n    key: \"setWidth\",\n    value: function setWidth(width) {\n      this._width = width;\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this._width;\n    }\n  }, {\n    key: \"setScaleX\",\n    value: function setScaleX(scaleX) {\n      this._scaleX = scaleX;\n    }\n  }, {\n    key: \"setScaleY\",\n    value: function setScaleY(scaleY) {\n      this._scaleY = scaleY;\n    }\n  }, {\n    key: \"getScaleX\",\n    value: function getScaleX() {\n      return this._scaleX;\n    }\n  }, {\n    key: \"getScaleY\",\n    value: function getScaleY() {\n      return this._scaleY;\n    }\n  }, {\n    key: \"setWidthHeightAABB\",\n    value: function setWidthHeightAABB(minWidth, minHeight, maxWidth, maxHeight) {\n      this._AABB_MaxWidth = maxWidth;\n      this._AABB_MaxHeight = maxHeight;\n      this._AABB_MinWidth = minWidth;\n      this._AABB_MinHeight = minHeight;\n    }\n  }, {\n    key: \"setDirectionLocked\",\n    value: function setDirectionLocked(value) {\n      this._directionLocked = value;\n    }\n  }, {\n    key: \"isDirectionLocked\",\n    value: function isDirectionLocked() {\n      return this._directionLocked;\n    }\n  }, {\n    key: \"getEntityDirection\",\n    value: function getEntityDirection() {\n      return this._direction;\n    }\n  }, {\n    key: \"setEntityDirection\",\n    value: function setEntityDirection(direction) {\n      if (isNaN(direction)) {\n        console.log(\"SetEntityDirection NaN\");\n      }\n\n      this._direction = direction;\n    }\n  }, {\n    key: \"setWeight\",\n    value: function setWeight(weight) {\n      this._weight = weight;\n    }\n  }, {\n    key: \"getWeight\",\n    value: function getWeight() {\n      return this._weight;\n    }\n  }, {\n    key: \"setBaseWeight\",\n    value: function setBaseWeight(weight) {\n      this._baseWeight = weight;\n    }\n  }, {\n    key: \"getBaseWeight\",\n    value: function getBaseWeight() {\n      return this._weight;\n    }\n  }, {\n    key: \"getRed\",\n    value: function getRed() {\n      return this._red;\n    }\n  }, {\n    key: \"setRed\",\n    value: function setRed(r) {\n      this._red = r;\n    }\n  }, {\n    key: \"getGreen\",\n    value: function getGreen() {\n      return this._green;\n    }\n  }, {\n    key: \"setGreen\",\n    value: function setGreen(g) {\n      this._green = g;\n    }\n  }, {\n    key: \"getBlue\",\n    value: function getBlue() {\n      return this._blue;\n    }\n  }, {\n    key: \"setBlue\",\n    value: function setBlue(b) {\n      this._blue = b;\n    }\n  }, {\n    key: \"getAge\",\n    value: function getAge() {\n      return this._age;\n    }\n  }, {\n    key: \"setAge\",\n    value: function setAge(age) {\n      this._age = age;\n    }\n  }, {\n    key: \"setEntityAlpha\",\n    value: function setEntityAlpha(alpha) {\n      this._alpha = alpha;\n    }\n  }, {\n    key: \"getOldWX\",\n    value: function getOldWX() {\n      return this._oldWX;\n    }\n  }, {\n    key: \"getOldWY\",\n    value: function getOldWY() {\n      return this._oldWY;\n    }\n  }, {\n    key: \"getImageDiameter\",\n    value: function getImageDiameter() {\n      return this._imageDiameter;\n    }\n  }, {\n    key: \"getOldAngle\",\n    value: function getOldAngle() {\n      return this._oldAngle;\n    }\n  }, {\n    key: \"getOldRelativeAngle\",\n    value: function getOldRelativeAngle() {\n      return this._oldRelativeAngle;\n    }\n  }, {\n    key: \"getAvatar\",\n    value: function getAvatar() {\n      return this._avatar;\n    }\n  }, {\n    key: \"getHandleX\",\n    value: function getHandleX() {\n      return this._handleX;\n    }\n  }, {\n    key: \"getHandleY\",\n    value: function getHandleY() {\n      return this._handleY;\n    }\n  }, {\n    key: \"getBlendMode\",\n    value: function getBlendMode() {\n      return this._blendMode;\n    }\n  }, {\n    key: \"getAngle\",\n    value: function getAngle() {\n      return this._angle;\n    }\n  }, {\n    key: \"getOldScaleX\",\n    value: function getOldScaleX() {\n      return this._oldScaleX;\n    }\n  }, {\n    key: \"getOldScaleY\",\n    value: function getOldScaleY() {\n      return this._oldScaleY;\n    }\n  }, {\n    key: \"getOldZ\",\n    value: function getOldZ() {\n      return this._oldZ;\n    }\n  }, {\n    key: \"setEntityColor\",\n    value: function setEntityColor(r, g, b) {\n      this._red = r;\n      this._green = g;\n      this._blue = b;\n    }\n  }, {\n    key: \"getEntityAlpha\",\n    value: function getEntityAlpha() {\n      return this._alpha;\n    }\n  }, {\n    key: \"getImageRadius\",\n    value: function getImageRadius() {\n      return this._imageRadius;\n    }\n  }, {\n    key: \"getFramerate\",\n    value: function getFramerate() {\n      return this._framerate;\n    }\n  }, {\n    key: \"setFramerate\",\n    value: function setFramerate(framerate) {\n      this._framerate = framerate;\n    }\n  }, {\n    key: \"isAnimating\",\n    value: function isAnimating() {\n      return this._animating;\n    }\n  }, {\n    key: \"setAnimating\",\n    value: function setAnimating(value) {\n      this._animating = value;\n    }\n  }, {\n    key: \"isRelative\",\n    value: function isRelative() {\n      return this._relative;\n    }\n  }, {\n    key: \"setWX\",\n    value: function setWX(wx) {\n      this._wx = wx;\n    }\n  }, {\n    key: \"setWY\",\n    value: function setWY(wy) {\n      this._wy = wy;\n    }\n  }, {\n    key: \"setAngle\",\n    value: function setAngle(degrees) {\n      if (isNaN(degrees)) {\n        console.log(\"SetAngle NaN\");\n      }\n\n      this._angle = degrees;\n    }\n  }, {\n    key: \"setHeight\",\n    value: function setHeight(height) {\n      this._height = height;\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this._height;\n    }\n  }, {\n    key: \"getParent\",\n    value: function getParent() {\n      return this._parent;\n    }\n  }, {\n    key: \"move\",\n    value: function move(xamount, yamount) {\n      this._x += xamount;\n      this._y += yamount;\n    }\n  }]);\n\n  return Entity;\n}();\n\nexports.default = Entity;\n\n//# sourceURL=webpack:///./src/Entity.js?");

/***/ }),

/***/ "./src/Matrix2.js":
/*!************************!*\
  !*** ./src/Matrix2.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Vector = __webpack_require__(/*! ./Vector2 */ \"./src/Vector2.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Matrix2 =\n/*#__PURE__*/\nfunction () {\n  function Matrix2() {\n    _classCallCheck(this, Matrix2);\n\n    this.set(1, 0, 0, 1);\n  }\n\n  _createClass(Matrix2, [{\n    key: \"create\",\n    value: function create() {\n      var aa_ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var ab_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var ba_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var bb_ = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var m = new Matrix2();\n      m.set(aa_, ab_, ba_, bb_);\n      return m;\n    }\n  }, {\n    key: \"set\",\n    value: function set() {\n      var aa_ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var ab_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var ba_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var bb_ = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      this.aa = aa_;\n      this.ab = ab_;\n      this.ba = ba_;\n      this.bb = bb_;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(s) {\n      this.aa *= s;\n      this.ab *= s;\n      this.ba *= s;\n      this.bb *= s;\n    }\n  }, {\n    key: \"transpose\",\n    value: function transpose(s) {\n      var abt = this.ab;\n      this.ab = this.ba;\n      this.ba = abt;\n    }\n  }, {\n    key: \"transformSelf\",\n    value: function transformSelf(m) {\n      var r_aa = this.aa * m.aa + this.ab * m.ba;\n      var r_ab = this.aa * m.ab + this.ab * m.bb;\n      var r_ba = this.ba * m.aa + this.bb * m.ba;\n      var r_bb = this.ba * m.ab + this.bb * m.bb;\n      this.set(r_aa, r_ab, r_ba, r_bb);\n    }\n  }, {\n    key: \"transformVector\",\n    value: function transformVector(x, y) {\n      var tv = new _Vector2.default();\n      tv.x = x * this.aa + y * this.ba;\n      tv.y = x * this.ab + y * this.bb;\n      return tv;\n    }\n  }]);\n\n  return Matrix2;\n}();\n\nexports.default = Matrix2;\n\n//# sourceURL=webpack:///./src/Matrix2.js?");

/***/ }),

/***/ "./src/Particle.js":
/*!*************************!*\
  !*** ./src/Particle.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Entity2 = __webpack_require__(/*! ./Entity */ \"./src/Entity.js\");\n\nvar _Entity3 = _interopRequireDefault(_Entity2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Particle =\n/*#__PURE__*/\nfunction (_Entity) {\n  _inherits(Particle, _Entity);\n\n  // Class(Entity, ...)\n  function Particle() {\n    var _this;\n\n    _classCallCheck(this, Particle);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Particle).call(this)); // Call parent's constructor\n\n    _this._emitter = null;\n    _this._weightVariation = 0;\n    _this._scaleVariationX = 0;\n    _this._scaleVariationY = 0;\n    _this._gSizeX = 0;\n    _this._gSizeY = 0;\n    _this._velVariation = 0;\n    _this._spinVariation = 0;\n    _this._directionVariation = 0;\n    _this._timeTracker = 0;\n    _this._randomDirection = 0;\n    _this._randomSpeed = 0;\n    _this._emissionAngle = 0;\n    _this._releaseSingleParticle = false;\n    _this._particleManager = null;\n    _this._layer = 0;\n    _this._groupParticles = false;\n    _this._effectLayer = 0;\n    return _this;\n  }\n\n  _createClass(Particle, [{\n    key: \"reset\",\n    value: function reset() {\n      this._age = 0;\n      this._wx = 0;\n      this._wy = 0;\n      this._z = 1.0;\n      this._avatar = null;\n      this._dead = 0;\n      this.clearChildren();\n      this._directionVariation = 0;\n      this._direction = 0;\n      this._directionLocked = false;\n      this._randomSpeed = 0;\n      this._randomDirection = 0;\n      this._parent = null;\n      this._rootParent = null;\n      this._aCycles = 0;\n      this._cCycles = 0;\n      this._rptAgeA = 0;\n      this._rptAgeC = 0;\n      this._releaseSingleParticle = false;\n      this._gravity = 0;\n      this._weight = 0;\n      this._emitter = null;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.capture();\n      if (this._emitter.isDying() || this._emitter.isOneShot() || this._dead) this._releaseSingleParticle = true;\n\n      if (this._emitter.isSingleParticle() && !this._releaseSingleParticle) {\n        this._age = this._particleManager.getCurrentTime() - this._dob;\n\n        if (this._age > this._lifeTime) {\n          this._age = 0;\n          this._dob = this._particleManager.getCurrentTime();\n        }\n      } else {\n        this._age = this._particleManager.getCurrentTime() - this._dob;\n      }\n\n      _get(_getPrototypeOf(Particle.prototype), \"update\", this).call(this); // Particle.$superp.Update.call(this);\n\n\n      if (this._age > this._lifeTime || this._dead == 2) {\n        // if dead=2 then that means its reached the end of the line (in kill mode) for line traversal effects\n        this._dead = 1;\n\n        if (this._children.length === 0) {\n          this._particleManager.releaseParticle(this); // TODO\n\n\n          if (this._emitter.isGroupParticles()) this._emitter.getParentEffect().removeInUse(this._layer, this); // TODO\n\n          this.reset();\n          return false; // RemoveChild\n        } else {\n          this._emitter.controlParticle(this);\n\n          this.killChildren();\n        }\n\n        return true;\n      }\n\n      this._emitter.controlParticle(this);\n\n      return true;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(releaseChildren) {\n      this._particleManager.releaseParticle(this); // TODO\n\n\n      _get(_getPrototypeOf(Particle.prototype), \"destroy\", this).call(this); // Particle.$superp.Destroy();\n\n\n      this.reset();\n    }\n  }, {\n    key: \"setX\",\n    value: function setX(x) {\n      this._oldX = this._age > 0 ? this._x : x;\n      this._x = x;\n    }\n  }, {\n    key: \"setY\",\n    value: function setY(y) {\n      this._oldY = this._age > 0 ? this._y : y;\n      this._y = y;\n    }\n  }, {\n    key: \"setZ\",\n    value: function setZ(z) {\n      this._oldZ = this._age > 0 ? this._z : z;\n      this._z = z;\n    }\n  }, {\n    key: \"setGroupParticles\",\n    value: function setGroupParticles(value) {\n      this._groupParticles = value;\n    }\n  }, {\n    key: \"isGroupParticles\",\n    value: function isGroupParticles() {\n      return this._groupParticles;\n    }\n  }, {\n    key: \"setLayer\",\n    value: function setLayer(layer) {\n      this._layer = layer;\n    }\n  }, {\n    key: \"getLayer\",\n    value: function getLayer() {\n      return this._layer;\n    }\n  }, {\n    key: \"setEmitter\",\n    value: function setEmitter(e) {\n      this._emitter = e;\n    }\n  }, {\n    key: \"getEmitter\",\n    value: function getEmitter() {\n      return this._emitter;\n    }\n  }, {\n    key: \"getEffectLayer\",\n    value: function getEffectLayer() {\n      return this._effectLayer;\n    }\n  }, {\n    key: \"setParticleManager\",\n    value: function setParticleManager(pm) {\n      this._particleManager = pm;\n    }\n  }, {\n    key: \"setEffectLayer\",\n    value: function setEffectLayer(layer) {\n      this._effectLayer = layer;\n    }\n  }, {\n    key: \"setVelVariation\",\n    value: function setVelVariation(velVariation) {\n      this._velVariation = velVariation;\n    }\n  }, {\n    key: \"getVelVariation\",\n    value: function getVelVariation() {\n      return this._velVariation;\n    }\n  }, {\n    key: \"setGSizeX\",\n    value: function setGSizeX(gSizeX) {\n      this._gSizeX = gSizeX;\n    }\n  }, {\n    key: \"setGSizeY\",\n    value: function setGSizeY(gSizeY) {\n      this._gSizeY = gSizeY;\n    }\n  }, {\n    key: \"getGSizeX\",\n    value: function getGSizeX() {\n      return this._gSizeX;\n    }\n  }, {\n    key: \"getGSizeY\",\n    value: function getGSizeY() {\n      return this._gSizeY;\n    }\n  }, {\n    key: \"setScaleVariationX\",\n    value: function setScaleVariationX(scaleVarX) {\n      this._scaleVariationX = scaleVarX;\n    }\n  }, {\n    key: \"getScaleVariationX\",\n    value: function getScaleVariationX() {\n      return this._scaleVariationX;\n    }\n  }, {\n    key: \"setScaleVariationY\",\n    value: function setScaleVariationY(scaleVarY) {\n      this._scaleVariationY = scaleVarY;\n    }\n  }, {\n    key: \"getScaleVariationY\",\n    value: function getScaleVariationY() {\n      return this._scaleVariationY;\n    }\n  }, {\n    key: \"setEmissionAngle\",\n    value: function setEmissionAngle(emissionAngle) {\n      this._emissionAngle = emissionAngle;\n    }\n  }, {\n    key: \"getEmissionAngle\",\n    value: function getEmissionAngle() {\n      return this._emissionAngle;\n    }\n  }, {\n    key: \"setDirectionVairation\",\n    value: function setDirectionVairation(dirVar) {\n      this._directionVariation = dirVar;\n    }\n  }, {\n    key: \"getDirectionVariation\",\n    value: function getDirectionVariation() {\n      return this._directionVariation;\n    }\n  }, {\n    key: \"setSpinVariation\",\n    value: function setSpinVariation(spinVar) {\n      this._spinVariation = spinVar;\n    }\n  }, {\n    key: \"getSpinVariation\",\n    value: function getSpinVariation() {\n      return this._spinVariation;\n    }\n  }, {\n    key: \"setWeightVariation\",\n    value: function setWeightVariation(weightVar) {\n      this._weightVariation = weightVar;\n    }\n  }, {\n    key: \"getWeightVariation\",\n    value: function getWeightVariation() {\n      return this._weightVariation;\n    }\n  }]);\n\n  return Particle;\n}(_Entity3.default);\n\nexports.default = Particle;\n\n//# sourceURL=webpack:///./src/Particle.js?");

/***/ }),

/***/ "./src/ParticleManager.js":
/*!********************************!*\
  !*** ./src/ParticleManager.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nvar _EffectsLibrary = __webpack_require__(/*! ./EffectsLibrary */ \"./src/EffectsLibrary.js\");\n\nvar _EffectsLibrary2 = _interopRequireDefault(_EffectsLibrary);\n\nvar _Particle = __webpack_require__(/*! ./Particle */ \"./src/Particle.js\");\n\nvar _Particle2 = _interopRequireDefault(_Particle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar ParticleManager =\n/*#__PURE__*/\nfunction () {\n  function ParticleManager(drawSprite) {\n    var particles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ParticleManager.c_particleLimit;\n    var layers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    _classCallCheck(this, ParticleManager);\n\n    _defineProperty(this, \"_drawSprite\", void 0);\n\n    this._drawSprite = drawSprite;\n    this._effectLayers = layers;\n    this._originX = 0;\n    this._originY = 0;\n    this._originZ = 1.0;\n    this._oldOriginX = 0;\n    this._oldOriginY = 0;\n    this._oldOriginZ = 1.0;\n    this._angle = 0;\n    this._oldAngle = 0;\n    this._vpW = 0;\n    this._vpH = 0;\n    this._vpX = 0;\n    this._vpY = 0;\n    this._centerX = 0;\n    this._centerY = 0;\n    this._angleTweened = 0;\n    this._globalAmountScale = 1.0;\n    this._camtx = 0;\n    this._camty = 0;\n    this._camtz = 0;\n    this._spawningAllowed = true;\n    this._testCount = 0;\n    this._paused = false;\n    this._currentTime = 0;\n    this._currentTick = 0;\n    this._idleTimeLimit = 100;\n    this._renderCount = 0;\n    this._currentTween = 0;\n    this._effectLayers = layers;\n    this._inUseCount = 0;\n    this._inUse = [];\n    this._effects = [];\n\n    for (var el = 0; el < layers; ++el) {\n      this._inUse[el] = [];\n      this._effects[el] = []; // Seems ridiculous\n\n      for (var i = 0; i < 10; ++i) {\n        this._inUse[el][i] = [];\n      }\n    }\n\n    this._unused = [];\n\n    for (var c = 0; c < particles; ++c) {\n      var p = new _Particle2.default();\n      p.setOKtoRender(false);\n\n      this._unused.push(p);\n    }\n  }\n\n  _createClass(ParticleManager, [{\n    key: \"update\",\n    value: function update() {\n      if (!this._paused) {\n        this._currentTime += _EffectsLibrary2.default.getUpdateTime();\n        this._currentTick++;\n\n        for (var i = 0; i < this._effectLayers; i++) {\n          var list = this._effects[i];\n\n          for (var j = 0; j < list.length; j++) {\n            if (!list[j].update()) {\n              list.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        this._oldOriginX = this._originX;\n        this._oldOriginY = this._originY;\n        this._oldOriginZ = this._originZ;\n      }\n    }\n  }, {\n    key: \"grabParticle\",\n    value: function grabParticle(effect, pool) {\n      var layer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (this._unused.length > 0) {\n        var p = this._unused.pop();\n\n        p.setLayer(layer);\n        p.setGroupParticles(pool);\n        if (pool) effect.addInUse(layer, p);else this._inUse[effect.getEffectLayer()][layer].push(p);\n        this._inUseCount++;\n        return p;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"releaseParticle\",\n    value: function releaseParticle(p) {\n      if (this.onParticleKilledCB) this.onParticleKilledCB(p);\n      this._inUseCount--;\n\n      this._unused.push(p);\n\n      if (!p.isGroupParticles()) {\n        var pList = this._inUse[p.getEffectLayer()][p.getLayer()];\n\n        (0, _Utils.removeFromList)(pList, p);\n      }\n    }\n  }, {\n    key: \"drawParticles\",\n    value: function drawParticles() {\n      var tween = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n      var layer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      // tween origin\n      this._currentTween = tween;\n      this._camtx = -(0, _Utils.lerp)(this._oldOriginX, this._originX, tween);\n      this._camty = -(0, _Utils.lerp)(this._oldOriginY, this._originY, tween);\n      this._camtz = (0, _Utils.lerp)(this._oldOriginZ, this._originZ, tween);\n\n      if (this._angle !== 0) {\n        this._angleTweened = (0, _Utils.lerp)(_oldAngle, _angle, tween);\n        var a = this._angleTweened / 180.0 * M_PI; //  this._matrix.Set(cos(a), sin(a), -sin(a), cos(a));  // CHECK\n      }\n\n      var layers = 0;\n      var startLayer = 0;\n\n      if (layer == -1 || layer >= this._effectLayers) {\n        layers = this._effectLayers - 1;\n      } else {\n        layers = layer;\n        startLayer = layer;\n      }\n\n      for (var el = startLayer; el <= layers; ++el) {\n        for (var i = 0; i < 10; ++i // wtf\n        ) {\n          var plist = this._inUse[el][i];\n\n          for (var j = 0; j < plist.length; j++) {\n            this.drawParticle(plist[j]);\n          }\n        }\n      }\n\n      this.drawEffects();\n    }\n  }, {\n    key: \"drawBoundingBoxes\",\n    value: function drawBoundingBoxes() {\n      for (var el = 0; el < this._effectLayers; ++el) {\n        var list = this._effects[el];\n\n        for (var j = 0; j < list.length; j++) {\n          list[j].drawBoundingBox();\n        }\n      }\n    }\n  }, {\n    key: \"setOrigin\",\n    value: function setOrigin(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;\n      this.setOriginX(x);\n      this.setOriginY(y);\n      this.setOriginZ(z);\n    }\n  }, {\n    key: \"setOriginX\",\n    value: function setOriginX(x) {\n      this._oldOriginX = this._originX;\n      this._originX = x;\n    }\n  }, {\n    key: \"setOriginY\",\n    value: function setOriginY(y) {\n      this._oldOriginY = this._originY;\n      this._originY = y;\n    }\n  }, {\n    key: \"setOriginZ\",\n    value: function setOriginZ(z) {\n      this._oldOriginZ = this._originZ;\n      this._originZ = z;\n    }\n  }, {\n    key: \"setAngle\",\n    value: function setAngle(angle) {\n      this._oldAngle = this._angle;\n      this._angle = angle;\n    }\n  }, {\n    key: \"setScreenSize\",\n    value: function setScreenSize(w, h) {\n      this._vpW = w;\n      this._vpH = h;\n      this._centerX = this._vpW / 2;\n      this._centerY = this._vpH / 2;\n    }\n  }, {\n    key: \"setScreenPosition\",\n    value: function setScreenPosition(x, y) {\n      this._vpX = x;\n      this._vpY = y;\n    }\n  }, {\n    key: \"setIdleTimeLimit\",\n    value: function setIdleTimeLimit(limit) {\n      this._idleTimeLimit = limit;\n    }\n  }, {\n    key: \"getOriginX\",\n    value: function getOriginX() {\n      return this._originX;\n    }\n  }, {\n    key: \"getOriginY\",\n    value: function getOriginY() {\n      return this._originY;\n    }\n  }, {\n    key: \"getOriginZ\",\n    value: function getOriginZ() {\n      return this._originZ;\n    }\n  }, {\n    key: \"getGlobalAmountScale\",\n    value: function getGlobalAmountScale() {\n      return this._globalAmountScale;\n    }\n  }, {\n    key: \"setGlobalAmountScale\",\n    value: function setGlobalAmountScale(scale) {\n      this._globalAmountScale = scale;\n    }\n  }, {\n    key: \"getParticlesInUse\",\n    value: function getParticlesInUse() {\n      return this._inUseCount;\n    }\n  }, {\n    key: \"getParticlesUnused\",\n    value: function getParticlesUnused() {\n      return this._unused.length;\n    }\n  }, {\n    key: \"addPreLoadedEffect\",\n    value: function addPreLoadedEffect(e, frames) {\n      var layer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (layer >= this._effectLayers) layer = 0;\n      var tempTime = this._currentTime;\n      this._currentTime -= frames * _EffectsLibrary2.default.getUpdateTime();\n      e.changeDoB(this._currentTime);\n\n      for (var i = 0; i < frames; ++i) {\n        this._currentTime = (frames + 1) * _EffectsLibrary2.default.getUpdateTime();\n        e.update();\n        if (e.isDestroyed()) this.removeEffect(e);\n      }\n\n      this._currentTime = tempTime;\n      e.setEffectLayer(layer);\n\n      this._effects[layer].push(e);\n    }\n  }, {\n    key: \"addEffect\",\n    value: function addEffect(e) {\n      var layer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (layer >= this._effectLayers) layer = 0;\n      e.setEffectLayer(layer);\n\n      this._effects[layer].push(e);\n    }\n  }, {\n    key: \"removeEffect\",\n    value: function removeEffect(e) {\n      (0, _Utils.removeFromList)(this._effects[e.getEffectLayer()], e);\n    }\n  }, {\n    key: \"clearInUse\",\n    value: function clearInUse() {\n      for (var el = 0; el < this._effectLayers; ++el) {\n        for (var i = 0; i < 10; ++i) {\n          var plist = this._inUse[el][i];\n\n          for (var j = 0; j < plist.length; j++) {\n            var p = plist[j];\n\n            this._unused.push(p);\n\n            this._inUseCount--;\n            p.getEmitter().getParentEffect().removeInUse(p.getLayer(), p);\n            p.reset();\n          }\n\n          this._inUse[el][i] = [];\n        }\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clearAll();\n      this.clearInUse();\n    }\n  }, {\n    key: \"clearAll\",\n    value: function clearAll() {\n      for (var el = 0; el < this._effectLayers; ++el) {\n        var elist = this._effects[el];\n\n        for (var j = 0; j < elist.length; j++) {\n          elist[j].destroy();\n        }\n\n        this._effects[el] = [];\n      }\n    }\n  }, {\n    key: \"clearLayer\",\n    value: function clearLayer(layer) {\n      var list = this._effects[layer];\n\n      for (var i = 0; i < list.length; i++) {\n        list[i].destroy();\n      }\n\n      this._effects[layer] = [];\n    }\n  }, {\n    key: \"releaseSingleParticles\",\n    value: function releaseSingleParticles() {\n      for (var i = 0; i < this._inUse.length; i++) {\n        var list = this._inUse[i];\n\n        for (var j = 0; j < list.length; j++) {\n          for (var k = 0; k < list[j].length; k++) {\n            list[j][k].setReleaseSingleParticles(true);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"togglePause\",\n    value: function togglePause() {\n      this._paused = !this._paused;\n    }\n  }, {\n    key: \"drawEffects\",\n    value: function drawEffects() {\n      for (var el = 0; el < this._effects.length; ++el) {\n        var elist = this._effects[el];\n\n        for (var j = 0; j < elist.length; j++) {\n          this.drawEffect(elist[j]);\n        }\n      }\n    }\n  }, {\n    key: \"drawEffect\",\n    value: function drawEffect(e) {\n      for (var i = 0; i < 10; ++i) {\n        // particle\n        var plist = e.getParticles(i);\n\n        for (var j = 0; j < plist.length; j++) {\n          this.drawParticle(plist[j]); // effect\n\n          var subeffects = plist[j].getChildren();\n\n          for (var k = 0; k < subeffects.length; k++) {\n            this.drawEffect(subeffects[k]);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"drawParticle\",\n    value: function drawParticle(p) {\n      // p: Particle\n      if (p.getAge() !== 0 || p.getEmitter().isSingleParticle()) {\n        var px = (0, _Utils.lerp)(p.getOldWX(), p.getWX(), this._currentTween);\n        var py = (0, _Utils.lerp)(p.getOldWY(), p.getWY(), this._currentTween);\n\n        if (this._angle !== 0) {\n          var rotVec = this._matrix.transformVector(new Vector2(px, py));\n\n          px = rotVec.x * this._camtz + this._centerX + this._camtz * this._camtx;\n          py = rotVec.y * this._camtz + this._centerY + this._camtz * this._camty;\n        } else {\n          px = px * this._camtz + this._centerX + this._camtz * this._camtx;\n          py = py * this._camtz + this._centerY + this._camtz * this._camty;\n        }\n\n        var imageDiam = p.getImageDiameter();\n\n        if (px > this._vpX - imageDiam && px < this._vpX + this._vpW + imageDiam && py > this._vpY - imageDiam && py < this._vpY + this._vpH + imageDiam) {\n          if (p.getAvatar()) {\n            var x, y;\n            var sprite = p.getAvatar();\n\n            if (p.getEmitter().isHandleCenter()) {\n              x = sprite.getWidth() / 2.0;\n              y = sprite.getHeight() / 2.0;\n            } else {\n              x = p.getHandleX();\n              y = p.getHandleY();\n            }\n\n            var rotation;\n            var tv = (0, _Utils.lerp)(p.getOldAngle(), p.getAngle(), this._currentTween);\n            var tx = 0;\n\n            if (p.getEmitter().isAngleRelative()) {\n              if (Math.abs(p.getOldRelativeAngle() - p.getRelativeAngle()) > 180) tx = (0, _Utils.lerp)(p.getOldRelativeAngle() - 360, p.getRelativeAngle(), this._currentTween);else tx = (0, _Utils.lerp)(p.getOldRelativeAngle(), p.getRelativeAngle(), this._currentTween);\n            }\n\n            rotation = tv + tx + this._angleTweened;\n            tx = (0, _Utils.lerp)(p.getOldScaleX(), p.getScaleX(), this._currentTween);\n            var ty = (0, _Utils.lerp)(p.getOldScaleY(), p.getScaleY(), this._currentTween);\n            var tz = (0, _Utils.lerp)(p.getOldZ(), p.getZ(), this._currentTween);\n            var scaleX = tx * tz * this._camtz;\n            var scaleY = ty * tz * this._camtz;\n            var a = p.getEntityAlpha();\n            var r = p.getRed();\n            var g = p.getGreen();\n            var b = p.getBlue();\n\n            if (p.isAnimating()) {\n              tv = (0, _Utils.lerp)(p.getOldCurrentFrame(), p.getCurrentFrame(), this._currentTween);\n\n              if (tv < 0) {\n                tv = p.getAvatar().getFramesCount() + (0, _Utils.fmod)(tv, p.getAvatar().getFramesCount());\n                if (tv == p.getAvatar().getFramesCount()) tv = 0;\n              } else {\n                tv = (0, _Utils.fmod)(tv, p.getAvatar().getFramesCount());\n              }\n            } else {\n              tv = p.getCurrentFrame();\n            } // tidy with above\n\n\n            tv = Math.round(tv) % p.getAvatar().getFramesCount();\n            var blend = p.getEmitter().getBlendMode();\n\n            this._drawSprite(p, sprite, px, py, tv, x, y, rotation, scaleX, scaleY, r, g, b, a, blend);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getIdleTimeLimit\",\n    value: function getIdleTimeLimit() {\n      return this._idleTimeLimit;\n    }\n  }, {\n    key: \"isSpawningAllowed\",\n    value: function isSpawningAllowed() {\n      return this._spawningAllowed;\n    }\n  }, {\n    key: \"getCurrentTime\",\n    value: function getCurrentTime() {\n      return this._currentTick * _EffectsLibrary2.default.getUpdateTime();\n    }\n  }]);\n\n  return ParticleManager;\n}();\n\n_defineProperty(ParticleManager, \"c_particleLimit\", 5000);\n\nexports.default = ParticleManager;\n\n//# sourceURL=webpack:///./src/ParticleManager.js?");

/***/ }),

/***/ "./src/Utils.js":
/*!**********************!*\
  !*** ./src/Utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeFromList = removeFromList;\nexports.stripFilePath = stripFilePath;\nexports.fmod = fmod;\nexports.degrees = degrees;\nexports.toRadians = toRadians;\nexports.getNodeAttrValue = getNodeAttrValue;\nexports.forEachInXMLNodeList = forEachInXMLNodeList;\nexports.forEachXMLChild = forEachXMLChild;\nexports.getXMLAttrSafe = getXMLAttrSafe;\nexports.lerp = lerp;\nexports.randomUnit = randomUnit;\nexports.random = random;\nexports.randomBetween = randomBetween;\nexports.getDistance2D = getDistance2D;\nexports.getDirection = getDirection;\nexports.loadXMLDoc = loadXMLDoc;\nexports.toHex = toHex;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction removeFromList(array, elem) {\n  var index = array.indexOf(elem);\n\n  if (index > -1) {\n    array.splice(index, 1);\n  }\n}\n\nvar M_PI = exports.M_PI = 3.14159265358979323846;\nvar g_randomSeed = exports.g_randomSeed = 17;\n\nfunction stripFilePath(filename) {\n  var index = Math.max(filename.lastIndexOf(\"/\"), filename.lastIndexOf(\"\\\\\"));\n  return filename.substring(index + 1);\n}\n\nfunction fmod(a, b) {\n  return Number((a - Math.floor(a / b) * b).toPrecision(8));\n}\n\nfunction degrees(rad) {\n  return rad * (180 / Math.PI);\n}\n\nfunction toRadians(deg) {\n  return deg * (Math.PI / 180);\n}\n\nvar CopyHelper =\n/*#__PURE__*/\nexports.CopyHelper = function () {\n  function CopyHelper(fromObj, toObj) {\n    _classCallCheck(this, CopyHelper);\n\n    this.m_fromObj = fromObj;\n    this.m_toObj = toObj;\n  }\n\n  _createClass(CopyHelper, [{\n    key: \"copy\",\n    value: function copy(key, defaultVal) {\n      this.m_toObj[key] = this.m_fromObj ? this.m_fromObj[key] : defaultVal;\n    }\n  }]);\n\n  return CopyHelper;\n}();\n\nvar XMLHelper =\n/*#__PURE__*/\nexports.XMLHelper = function () {\n  function XMLHelper(xml) {\n    _classCallCheck(this, XMLHelper);\n\n    this.m_xml = xml;\n    this.m_attr = xml.attributes;\n  }\n\n  _createClass(XMLHelper, [{\n    key: \"getAttr\",\n    value: function getAttr(attrName) {\n      var attr = this.m_attr.getNamedItem(attrName);\n      return attr ? attr.nodeValue : null;\n    }\n  }, {\n    key: \"getAttrAsInt\",\n    value: function getAttrAsInt(attrName) {\n      return parseInt(this.getAttr(attrName));\n    }\n  }, {\n    key: \"getAttrAsFloat\",\n    value: function getAttrAsFloat(attrName) {\n      return parseFloat(this.getAttr(attrName));\n    }\n  }, {\n    key: \"getAttrAsBool\",\n    value: function getAttrAsBool(attrName) {\n      return this.getAttrAsInt(attrName) > 0;\n    }\n  }, {\n    key: \"getChildAttr\",\n    value: function getChildAttr(childName, attrName) {\n      var childNode = this.m_xml.getElementsByTagName(childName)[0];\n      if (childNode) return getXMLAttrSafe(childNode, attrName, null);\n      return null;\n    }\n  }, {\n    key: \"hasChildAttr\",\n    value: function hasChildAttr(attrName) {\n      return this.getChildAttr(attrName) !== null;\n    }\n  }, {\n    key: \"getChildAttrAsInt\",\n    value: function getChildAttrAsInt(attrName) {\n      return parseInt(this.getChildAttr(attrName));\n    }\n  }, {\n    key: \"getChildAttrAsBool\",\n    value: function getChildAttrAsBool(attrName) {\n      return this.getChildAttrAsInt(attrName) > 0;\n    }\n  }]);\n\n  return XMLHelper;\n}();\n\nfunction getNodeAttrValue(elem, attrName) {\n  return elem.attributes.getNamedItem(attrName).nodeValue;\n}\n\nfunction forEachInXMLNodeList(nodelist, fn) {\n  for (var i = 0; i < nodelist.length; i++) {\n    fn(nodelist[i]);\n  }\n}\n\nfunction forEachXMLChild(xmlNode, tag, fn) {\n  var nodelist = xmlNode.getElementsByTagName(tag);\n\n  for (var i = 0; i < nodelist.length; i++) {\n    if (nodelist[i].parentElement == xmlNode) fn(nodelist[i]);\n  }\n}\n\nfunction getXMLAttrSafe(xmlNode, attrName) {\n  var defaultResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var attr = xmlNode.attributes ? xmlNode.attributes.getNamedItem(attrName) : null;\n  return attr ? attr.nodeValue : defaultResult;\n}\n\nfunction lerp(a, b, fract) {\n  return a + fract * (b - a);\n} // http://stackoverflow.com/questions/521295/javascript-random-seeds\n\n\nfunction randomUnit() {\n  var x = Math.sin((exports.g_randomSeed = g_randomSeed += 1, g_randomSeed - 1)) * 10000;\n  return x - Math.floor(x);\n}\n\nfunction random(mag) {\n  return randomUnit() * mag;\n}\n\nfunction randomBetween(low, high) {\n  return lerp(low, high, randomUnit());\n}\n\nfunction getDistance2D(fromx, fromy, tox, toy) {\n  var fast = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var w = tox - fromx;\n  var h = toy - fromy;\n\n  if (fast) {\n    return w * w + h * h;\n  } else {\n    return Math.sqrt(w * w + h * h);\n  }\n}\n/**\n * Get the direction from 1 point to another\n * Thanks to \"Snarkbait\" for this little code snippit\n * @return Angle of difference\n */\n\n\nfunction getDirection(fromx, fromy, tox, toy) {\n  // arcus tangens, convert to degrees, add 450 and normalize to 360.\n  return fmod(Math.atan2(toy - fromy, tox - fromx) / M_PI * 180.0 + 450.0, 360.0);\n}\n\nfunction loadXMLDoc(filename) {\n  var xhttp = new XMLHttpRequest();\n  xhttp.open(\"GET\", filename, false);\n  xhttp.send();\n  return xhttp.responseXML;\n}\n\nfunction toHex(r, g, b) {\n  return (r << 16) + (g << 8) + b;\n}\n\n//# sourceURL=webpack:///./src/Utils.js?");

/***/ }),

/***/ "./src/Vector2.js":
/*!************************!*\
  !*** ./src/Vector2.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Vector2 =\n/*#__PURE__*/\nfunction () {\n  function Vector2(x, y) {\n    _classCallCheck(this, Vector2);\n\n    this.set(x, y);\n  }\n\n  _createClass(Vector2, [{\n    key: \"create\",\n    value: function create(x, y) {\n      return new Vector2(x, y);\n    }\n  }, {\n    key: \"set\",\n    value: function set(vx, vy) {\n      this.x = vx;\n      this.y = vy;\n    }\n  }, {\n    key: \"move1\",\n    value: function move1(other) {\n      return this.Move2(other.x, other.y);\n    }\n  }, {\n    key: \"move2\",\n    value: function move2(vx, vy) {\n      this.x += vx;\n      this.y += vy;\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(v) {\n      return new Vector2(x - v.x, y - v.y);\n    }\n  }, {\n    key: \"add\",\n    value: function add(v) {\n      return new Vector2(x + v.x, y + v.y);\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(v) {\n      return new Vector2(x * v.x, y * v.y);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(_scale) {\n      return new Vector2(x * _scale, y * _scale);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(x * x + y * y);\n    }\n  }, {\n    key: \"unit\",\n    value: function unit() {\n      var length = this.length();\n\n      if (length > 0) {\n        return new Vector2(v.x = x / length, v.y = y / length);\n      }\n\n      return new Vector2(0, 0);\n    }\n  }, {\n    key: \"normal\",\n    value: function normal() {\n      return new Vector2(-y, x);\n    }\n  }, {\n    key: \"leftNormal\",\n    value: function leftNormal() {\n      return new Vector2(y, -x);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var length = this.length(); // Length\n\n      if (length > 0) {\n        this.x /= length;\n        this.y /= length;\n      }\n    }\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(v) {\n      return x * v.x + y * v.y;\n    }\n  }]);\n\n  return Vector2;\n}();\n\nexports.default = Vector2;\n\n//# sourceURL=webpack:///./src/Vector2.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _ParticleManager = __webpack_require__(/*! ./ParticleManager */ \"./src/ParticleManager.js\");\n\nvar _ParticleManager2 = _interopRequireDefault(_ParticleManager);\n\nvar _Effect = __webpack_require__(/*! ./Effect */ \"./src/Effect.js\");\n\nvar _Effect2 = _interopRequireDefault(_Effect);\n\nvar _Entity = __webpack_require__(/*! ./Entity */ \"./src/Entity.js\");\n\nvar _Particle = __webpack_require__(/*! ./Particle */ \"./src/Particle.js\");\n\nvar _Particle2 = _interopRequireDefault(_Particle);\n\nvar _EffectsLibrary = __webpack_require__(/*! ./EffectsLibrary */ \"./src/EffectsLibrary.js\");\n\nvar _EffectsLibrary2 = _interopRequireDefault(_EffectsLibrary);\n\nvar _Utils = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\ndocument.addEventListener(\"DOMContentLoaded\", start);\nvar g_particleManager = new _ParticleManager2.default(DrawSprite, 1000, 1);\ng_particleManager.onParticleSpawnCB = OnParticleSpawned;\ng_particleManager.onParticleKilledCB = OnParticleKilled;\nvar g_renderCnt;\nvar g_xml = null;\nvar g_stage = null;\nvar g_renderer = null;\nvar g_loadingTextures = [];\nvar g_path = \"./\";\nvar g_currentEffectPrototype = null;\nvar g_currentEffectInstance = null;\n\nfunction StartEffect() {\n  if (g_currentEffectInstance) g_particleManager.removeEffect(g_currentEffectInstance);\n\n  if (g_currentEffectPrototype) {\n    g_currentEffectInstance = new _Effect2.default(g_currentEffectPrototype, g_particleManager);\n    g_particleManager.addEffect(g_currentEffectInstance);\n  }\n}\n\nfunction PlayEffect(name) {\n  HideHome();\n  if (g_currentEffectInstance) g_currentEffectInstance.softKill();\n  g_currentEffectPrototype = _EffectsLibrary2.default.getEffect(name);\n  g_currentEffectPrototype.compileAll();\n  console.log(\"PlayEffect:\" + name);\n}\n\nfunction RegisterEffect(e, name) {\n  var menu = document.getElementById(\"fxMenu\");\n  var li = document.createElement(\"li\");\n  li.className = \"pure-menu-item\"; //  presumably can set an onCLick handler via js? on textNode perhaps?\n  // then pass the actuall effect instead of the name around?\n\n  var str = '<a href=\"#\" class=\"pure-menu-link\" onClick=\"PlayEffect(\\'';\n  str += name;\n  str += \"')\\\">\";\n  str += name;\n  str += \"</a>\";\n  li.appendChild(document.createTextNode(\"\"));\n  li.innerHTML = str;\n  menu.appendChild(li); // Start pre-loading all required images\n\n  var requiredImages = [];\n  e.getImages(requiredImages);\n\n  for (var imageIndex in requiredImages) {\n    var animImage = requiredImages[imageIndex];\n\n    if (!animImage.m_pixiTexture) {\n      var filename = g_path + (0, _Utils.stripFilePath)(animImage.getFilename());\n      animImage.m_pixiTexture = PIXI.Texture.fromImage(filename);\n      g_loadingTextures.push(animImage);\n    }\n  }\n}\n\nvar g_particleCountText;\n\nfunction start() {\n  console.log(\"LOADED HERE\");\n  var w = window.innerWidth - 250;\n  var h = window.innerHeight - 4;\n  g_renderer = PIXI.autoDetectRenderer(w, h);\n  var fxdiv = document.getElementById(\"fxdiv\");\n  fxdiv.appendChild(g_renderer.view);\n  g_stage = new PIXI.Container(); // create some white text using the Snippet webfont\n\n  g_particleCountText = new PIXI.Text(\"Active Particles:\", {\n    font: \"12px Courier New\",\n    fill: \"white\",\n    align: \"center\"\n  });\n  g_particleCountText.position.x = 0.8 * w;\n  g_particleCountText.position.y = 0.95 * h;\n  g_stage.addChild(g_particleCountText);\n  g_xml = (0, _Utils.loadXMLDoc)(g_path + \"data.xml\");\n  g_particleManager.setScreenSize(w, h);\n\n  _EffectsLibrary2.default.init();\n\n  _EffectsLibrary2.default.load(g_xml);\n\n  for (var eName in _EffectsLibrary2.default._effects) {\n    var e = _EffectsLibrary2.default._effects[eName];\n\n    if (!e.getParentEmitter()) {\n      RegisterEffect(e, eName);\n    }\n  }\n\n  requestAnimationFrame(Animate);\n}\n\nfunction OnTextureLoaded(animImage) {\n  var totalWidth = animImage.m_pixiTexture.baseTexture.width;\n  animImage._horizCells = totalWidth / animImage._width;\n  var numFrames = animImage.getFramesCount();\n  animImage.m_pixiFrames = [];\n\n  if (numFrames == 1) {\n    animImage.m_pixiFrames[0] = animImage.m_pixiTexture;\n  } else {\n    for (var f = 0; f < numFrames; f++) {\n      var x = animImage.getFrameX(f);\n      var y = animImage.getFrameY(f); // Weird that it needs -1\n\n      var rect = new PIXI.Rectangle(x, y, animImage.getWidth() - 1, animImage.getHeight() - 1);\n      animImage.m_pixiFrames[f] = new PIXI.Texture(animImage.m_pixiTexture, rect);\n    }\n  }\n}\n\nfunction OnParticleSpawned(p) {\n  var animImage = p.getAvatar();\n\n  if (p.m_pixiSprite) {\n    p.m_pixiSprite.texture = animImage.m_pixiFrames[0];\n  } else {\n    p.m_pixiSprite = new PIXI.Sprite(animImage.m_pixiFrames[0]);\n  }\n\n  var emit = p.getEmitter();\n\n  if (p.getEmitter().isHandleCenter()) {\n    p.m_pixiSprite.anchor.set(0.5);\n  } else {\n    p.m_pixiSprite.anchor.x = p.getHandleX() / animImage._width;\n    p.m_pixiSprite.anchor.y = p.getHandleY() / animImage._height;\n  }\n\n  p.m_pixiSprite.visible = false;\n  g_stage.addChild(p.m_pixiSprite);\n}\n\nfunction OnParticleKilled(p) {\n  g_stage.removeChild(p.m_pixiSprite);\n}\n\nfunction DrawSprite(p, sprite, px, py, tv, x, y, rotation, scaleX, scaleY, r, g, b, a, blendMode) {\n  p.m_pixiSprite.visible = true;\n  g_renderCnt++;\n  p.m_pixiSprite.texture = sprite.m_pixiFrames[tv];\n  p.m_pixiSprite.position.x = px;\n  p.m_pixiSprite.position.y = py;\n  p.m_pixiSprite.alpha = a;\n  p.m_pixiSprite.tint = (0, _Utils.toHex)(r, g, b);\n  p.m_pixiSprite.rotation = (0, _Utils.toRadians)(rotation);\n  p.m_pixiSprite.scale.x = scaleX;\n  p.m_pixiSprite.scale.y = scaleY; // looks best for explosions anyway..\n  // These are the closest equivalent blend modes currently available in WebGL (I think), and give the closest appearance for most effects tested.\n\n  p.m_pixiSprite.blendMode = PIXI.BLEND_MODES.NORMAL; // or should the default be something else?\n\n  if (blendMode == _Entity.Blend.BMLightBlend) p.m_pixiSprite.blendMode = PIXI.BLEND_MODES.SCREEN;\n}\n\nfunction Animate() {\n  while (g_loadingTextures.length > 0) {\n    var animImage = g_loadingTextures[g_loadingTextures.length - 1];\n\n    if (animImage.m_pixiTexture.baseTexture.hasLoaded) {\n      OnTextureLoaded(animImage);\n      g_loadingTextures.pop();\n\n      if (g_loadingTextures.length === 0) {\n        console.log(\"All textures loaded\");\n      }\n    } else {\n      // Show loading state if not all loaded?\n      requestAnimationFrame(Animate);\n      return;\n    }\n  }\n\n  g_renderCnt = 0;\n  g_particleManager.update();\n  g_particleManager.drawParticles(); //console.log(g_renderCnt);\n\n  g_renderer.render(g_stage); // request another animation frame...\n\n  requestAnimationFrame(Animate);\n  g_particleCountText.setText(\"Active Particles:\" + g_particleManager.getParticlesInUse());\n\n  if (g_particleManager.getParticlesInUse() === 0) {\n    StartEffect();\n  }\n}\n\nwindow.PlayEffect = PlayEffect;\nwindow.StartEffect = StartEffect;\nwindow.Animate = Animate;\nwindow.DrawSprite = DrawSprite;\nwindow.OnTextureLoaded = OnTextureLoaded;\nwindow.OnParticleKilled = OnParticleKilled;\nwindow.OnParticleSpawned = OnParticleSpawned;\nwindow.RegisterEffect = RegisterEffect;\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });